// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: primary.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_primary_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_primary_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_primary_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_primary_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_primary_2eproto;
namespace primary {
class CAR_STATUS;
struct CAR_STATUSDefaultTypeInternal;
extern CAR_STATUSDefaultTypeInternal _CAR_STATUS_default_instance_;
class COOLING_STATUS;
struct COOLING_STATUSDefaultTypeInternal;
extern COOLING_STATUSDefaultTypeInternal _COOLING_STATUS_default_instance_;
class DAS_VERSION;
struct DAS_VERSIONDefaultTypeInternal;
extern DAS_VERSIONDefaultTypeInternal _DAS_VERSION_default_instance_;
class HANDCART_STATUS;
struct HANDCART_STATUSDefaultTypeInternal;
extern HANDCART_STATUSDefaultTypeInternal _HANDCART_STATUS_default_instance_;
class HV_CELLS_TEMP;
struct HV_CELLS_TEMPDefaultTypeInternal;
extern HV_CELLS_TEMPDefaultTypeInternal _HV_CELLS_TEMP_default_instance_;
class HV_CELLS_VOLTAGE;
struct HV_CELLS_VOLTAGEDefaultTypeInternal;
extern HV_CELLS_VOLTAGEDefaultTypeInternal _HV_CELLS_VOLTAGE_default_instance_;
class HV_CELL_BALANCING_STATUS;
struct HV_CELL_BALANCING_STATUSDefaultTypeInternal;
extern HV_CELL_BALANCING_STATUSDefaultTypeInternal _HV_CELL_BALANCING_STATUS_default_instance_;
class HV_CURRENT;
struct HV_CURRENTDefaultTypeInternal;
extern HV_CURRENTDefaultTypeInternal _HV_CURRENT_default_instance_;
class HV_ERRORS;
struct HV_ERRORSDefaultTypeInternal;
extern HV_ERRORSDefaultTypeInternal _HV_ERRORS_default_instance_;
class HV_TEMP;
struct HV_TEMPDefaultTypeInternal;
extern HV_TEMPDefaultTypeInternal _HV_TEMP_default_instance_;
class HV_VERSION;
struct HV_VERSIONDefaultTypeInternal;
extern HV_VERSIONDefaultTypeInternal _HV_VERSION_default_instance_;
class HV_VOLTAGE;
struct HV_VOLTAGEDefaultTypeInternal;
extern HV_VOLTAGEDefaultTypeInternal _HV_VOLTAGE_default_instance_;
class LV_CURRENT;
struct LV_CURRENTDefaultTypeInternal;
extern LV_CURRENTDefaultTypeInternal _LV_CURRENT_default_instance_;
class LV_TEMPERATURE;
struct LV_TEMPERATUREDefaultTypeInternal;
extern LV_TEMPERATUREDefaultTypeInternal _LV_TEMPERATURE_default_instance_;
class LV_VERSION;
struct LV_VERSIONDefaultTypeInternal;
extern LV_VERSIONDefaultTypeInternal _LV_VERSION_default_instance_;
class LV_VOLTAGE;
struct LV_VOLTAGEDefaultTypeInternal;
extern LV_VOLTAGEDefaultTypeInternal _LV_VOLTAGE_default_instance_;
class SET_CAR_STATUS;
struct SET_CAR_STATUSDefaultTypeInternal;
extern SET_CAR_STATUSDefaultTypeInternal _SET_CAR_STATUS_default_instance_;
class SET_CELL_BALANCING_STATUS;
struct SET_CELL_BALANCING_STATUSDefaultTypeInternal;
extern SET_CELL_BALANCING_STATUSDefaultTypeInternal _SET_CELL_BALANCING_STATUS_default_instance_;
class SET_PEDALS_RANGE;
struct SET_PEDALS_RANGEDefaultTypeInternal;
extern SET_PEDALS_RANGEDefaultTypeInternal _SET_PEDALS_RANGE_default_instance_;
class SET_TLM_STATUS;
struct SET_TLM_STATUSDefaultTypeInternal;
extern SET_TLM_STATUSDefaultTypeInternal _SET_TLM_STATUS_default_instance_;
class SET_TS_STATUS;
struct SET_TS_STATUSDefaultTypeInternal;
extern SET_TS_STATUSDefaultTypeInternal _SET_TS_STATUS_default_instance_;
class SPEED;
struct SPEEDDefaultTypeInternal;
extern SPEEDDefaultTypeInternal _SPEED_default_instance_;
class STEER_STATUS;
struct STEER_STATUSDefaultTypeInternal;
extern STEER_STATUSDefaultTypeInternal _STEER_STATUS_default_instance_;
class STEER_SYSTEM_STATUS;
struct STEER_SYSTEM_STATUSDefaultTypeInternal;
extern STEER_SYSTEM_STATUSDefaultTypeInternal _STEER_SYSTEM_STATUS_default_instance_;
class STEER_VERSION;
struct STEER_VERSIONDefaultTypeInternal;
extern STEER_VERSIONDefaultTypeInternal _STEER_VERSION_default_instance_;
class TIMESTAMP;
struct TIMESTAMPDefaultTypeInternal;
extern TIMESTAMPDefaultTypeInternal _TIMESTAMP_default_instance_;
class TLM_STATUS;
struct TLM_STATUSDefaultTypeInternal;
extern TLM_STATUSDefaultTypeInternal _TLM_STATUS_default_instance_;
class TLM_VERSION;
struct TLM_VERSIONDefaultTypeInternal;
extern TLM_VERSIONDefaultTypeInternal _TLM_VERSION_default_instance_;
class TS_STATUS;
struct TS_STATUSDefaultTypeInternal;
extern TS_STATUSDefaultTypeInternal _TS_STATUS_default_instance_;
}  // namespace primary
PROTOBUF_NAMESPACE_OPEN
template<> ::primary::CAR_STATUS* Arena::CreateMaybeMessage<::primary::CAR_STATUS>(Arena*);
template<> ::primary::COOLING_STATUS* Arena::CreateMaybeMessage<::primary::COOLING_STATUS>(Arena*);
template<> ::primary::DAS_VERSION* Arena::CreateMaybeMessage<::primary::DAS_VERSION>(Arena*);
template<> ::primary::HANDCART_STATUS* Arena::CreateMaybeMessage<::primary::HANDCART_STATUS>(Arena*);
template<> ::primary::HV_CELLS_TEMP* Arena::CreateMaybeMessage<::primary::HV_CELLS_TEMP>(Arena*);
template<> ::primary::HV_CELLS_VOLTAGE* Arena::CreateMaybeMessage<::primary::HV_CELLS_VOLTAGE>(Arena*);
template<> ::primary::HV_CELL_BALANCING_STATUS* Arena::CreateMaybeMessage<::primary::HV_CELL_BALANCING_STATUS>(Arena*);
template<> ::primary::HV_CURRENT* Arena::CreateMaybeMessage<::primary::HV_CURRENT>(Arena*);
template<> ::primary::HV_ERRORS* Arena::CreateMaybeMessage<::primary::HV_ERRORS>(Arena*);
template<> ::primary::HV_TEMP* Arena::CreateMaybeMessage<::primary::HV_TEMP>(Arena*);
template<> ::primary::HV_VERSION* Arena::CreateMaybeMessage<::primary::HV_VERSION>(Arena*);
template<> ::primary::HV_VOLTAGE* Arena::CreateMaybeMessage<::primary::HV_VOLTAGE>(Arena*);
template<> ::primary::LV_CURRENT* Arena::CreateMaybeMessage<::primary::LV_CURRENT>(Arena*);
template<> ::primary::LV_TEMPERATURE* Arena::CreateMaybeMessage<::primary::LV_TEMPERATURE>(Arena*);
template<> ::primary::LV_VERSION* Arena::CreateMaybeMessage<::primary::LV_VERSION>(Arena*);
template<> ::primary::LV_VOLTAGE* Arena::CreateMaybeMessage<::primary::LV_VOLTAGE>(Arena*);
template<> ::primary::SET_CAR_STATUS* Arena::CreateMaybeMessage<::primary::SET_CAR_STATUS>(Arena*);
template<> ::primary::SET_CELL_BALANCING_STATUS* Arena::CreateMaybeMessage<::primary::SET_CELL_BALANCING_STATUS>(Arena*);
template<> ::primary::SET_PEDALS_RANGE* Arena::CreateMaybeMessage<::primary::SET_PEDALS_RANGE>(Arena*);
template<> ::primary::SET_TLM_STATUS* Arena::CreateMaybeMessage<::primary::SET_TLM_STATUS>(Arena*);
template<> ::primary::SET_TS_STATUS* Arena::CreateMaybeMessage<::primary::SET_TS_STATUS>(Arena*);
template<> ::primary::SPEED* Arena::CreateMaybeMessage<::primary::SPEED>(Arena*);
template<> ::primary::STEER_STATUS* Arena::CreateMaybeMessage<::primary::STEER_STATUS>(Arena*);
template<> ::primary::STEER_SYSTEM_STATUS* Arena::CreateMaybeMessage<::primary::STEER_SYSTEM_STATUS>(Arena*);
template<> ::primary::STEER_VERSION* Arena::CreateMaybeMessage<::primary::STEER_VERSION>(Arena*);
template<> ::primary::TIMESTAMP* Arena::CreateMaybeMessage<::primary::TIMESTAMP>(Arena*);
template<> ::primary::TLM_STATUS* Arena::CreateMaybeMessage<::primary::TLM_STATUS>(Arena*);
template<> ::primary::TLM_VERSION* Arena::CreateMaybeMessage<::primary::TLM_VERSION>(Arena*);
template<> ::primary::TS_STATUS* Arena::CreateMaybeMessage<::primary::TS_STATUS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace primary {

enum Tlm_Status_Set : int {
  TLM_STATUS_SET_OFF = 0,
  TLM_STATUS_SET_ON = 1,
  Tlm_Status_Set_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Tlm_Status_Set_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Tlm_Status_Set_IsValid(int value);
constexpr Tlm_Status_Set Tlm_Status_Set_MIN = TLM_STATUS_SET_OFF;
constexpr Tlm_Status_Set Tlm_Status_Set_MAX = TLM_STATUS_SET_ON;
constexpr int Tlm_Status_Set_ARRAYSIZE = Tlm_Status_Set_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tlm_Status_Set_descriptor();
template<typename T>
inline const std::string& Tlm_Status_Set_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tlm_Status_Set>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tlm_Status_Set_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tlm_Status_Set_descriptor(), enum_t_value);
}
inline bool Tlm_Status_Set_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tlm_Status_Set* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tlm_Status_Set>(
    Tlm_Status_Set_descriptor(), name, value);
}
enum Race_Type : int {
  RACE_TYPE_ACCELERATION = 0,
  RACE_TYPE_SKIDPAD = 1,
  RACE_TYPE_AUTOCROSS = 2,
  RACE_TYPE_ENDURANCE = 3,
  Race_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Race_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Race_Type_IsValid(int value);
constexpr Race_Type Race_Type_MIN = RACE_TYPE_ACCELERATION;
constexpr Race_Type Race_Type_MAX = RACE_TYPE_ENDURANCE;
constexpr int Race_Type_ARRAYSIZE = Race_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Race_Type_descriptor();
template<typename T>
inline const std::string& Race_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Race_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Race_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Race_Type_descriptor(), enum_t_value);
}
inline bool Race_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Race_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Race_Type>(
    Race_Type_descriptor(), name, value);
}
enum Tlm_Status : int {
  TLM_STATUS_ON = 0,
  TLM_STATUS_OFF = 1,
  Tlm_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Tlm_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Tlm_Status_IsValid(int value);
constexpr Tlm_Status Tlm_Status_MIN = TLM_STATUS_ON;
constexpr Tlm_Status Tlm_Status_MAX = TLM_STATUS_OFF;
constexpr int Tlm_Status_ARRAYSIZE = Tlm_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Tlm_Status_descriptor();
template<typename T>
inline const std::string& Tlm_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Tlm_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Tlm_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Tlm_Status_descriptor(), enum_t_value);
}
inline bool Tlm_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tlm_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Tlm_Status>(
    Tlm_Status_descriptor(), name, value);
}
enum Inverter_Status : int {
  INVERTER_STATUS_OFF = 0,
  INVERTER_STATUS_IDLE = 1,
  INVERTER_STATUS_ON = 2,
  Inverter_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Inverter_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Inverter_Status_IsValid(int value);
constexpr Inverter_Status Inverter_Status_MIN = INVERTER_STATUS_OFF;
constexpr Inverter_Status Inverter_Status_MAX = INVERTER_STATUS_ON;
constexpr int Inverter_Status_ARRAYSIZE = Inverter_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Inverter_Status_descriptor();
template<typename T>
inline const std::string& Inverter_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Inverter_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Inverter_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Inverter_Status_descriptor(), enum_t_value);
}
inline bool Inverter_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Inverter_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Inverter_Status>(
    Inverter_Status_descriptor(), name, value);
}
enum Car_Status : int {
  CAR_STATUS_IDLE = 0,
  CAR_STATUS_SETUP = 1,
  CAR_STATUS_RUN = 2,
  Car_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Car_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Car_Status_IsValid(int value);
constexpr Car_Status Car_Status_MIN = CAR_STATUS_IDLE;
constexpr Car_Status Car_Status_MAX = CAR_STATUS_RUN;
constexpr int Car_Status_ARRAYSIZE = Car_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Car_Status_descriptor();
template<typename T>
inline const std::string& Car_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Car_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Car_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Car_Status_descriptor(), enum_t_value);
}
inline bool Car_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Car_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Car_Status>(
    Car_Status_descriptor(), name, value);
}
enum Ts_Status : int {
  TS_STATUS_OFF = 0,
  TS_STATUS_PRECHARGE = 1,
  TS_STATUS_ON = 2,
  TS_STATUS_FATAL = 3,
  Ts_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Ts_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Ts_Status_IsValid(int value);
constexpr Ts_Status Ts_Status_MIN = TS_STATUS_OFF;
constexpr Ts_Status Ts_Status_MAX = TS_STATUS_FATAL;
constexpr int Ts_Status_ARRAYSIZE = Ts_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Ts_Status_descriptor();
template<typename T>
inline const std::string& Ts_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Ts_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Ts_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Ts_Status_descriptor(), enum_t_value);
}
inline bool Ts_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Ts_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Ts_Status>(
    Ts_Status_descriptor(), name, value);
}
enum Ts_Status_Set : int {
  TS_STATUS_SET_OFF = 0,
  TS_STATUS_SET_ON = 1,
  Ts_Status_Set_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Ts_Status_Set_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Ts_Status_Set_IsValid(int value);
constexpr Ts_Status_Set Ts_Status_Set_MIN = TS_STATUS_SET_OFF;
constexpr Ts_Status_Set Ts_Status_Set_MAX = TS_STATUS_SET_ON;
constexpr int Ts_Status_Set_ARRAYSIZE = Ts_Status_Set_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Ts_Status_Set_descriptor();
template<typename T>
inline const std::string& Ts_Status_Set_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Ts_Status_Set>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Ts_Status_Set_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Ts_Status_Set_descriptor(), enum_t_value);
}
inline bool Ts_Status_Set_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Ts_Status_Set* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Ts_Status_Set>(
    Ts_Status_Set_descriptor(), name, value);
}
enum Set_Balancing_Status : int {
  SET_BALANCING_STATUS_OFF = 0,
  SET_BALANCING_STATUS_ON = 1,
  Set_Balancing_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Set_Balancing_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Set_Balancing_Status_IsValid(int value);
constexpr Set_Balancing_Status Set_Balancing_Status_MIN = SET_BALANCING_STATUS_OFF;
constexpr Set_Balancing_Status Set_Balancing_Status_MAX = SET_BALANCING_STATUS_ON;
constexpr int Set_Balancing_Status_ARRAYSIZE = Set_Balancing_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Set_Balancing_Status_descriptor();
template<typename T>
inline const std::string& Set_Balancing_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Set_Balancing_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Set_Balancing_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Set_Balancing_Status_descriptor(), enum_t_value);
}
inline bool Set_Balancing_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Set_Balancing_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Set_Balancing_Status>(
    Set_Balancing_Status_descriptor(), name, value);
}
enum Traction_Control : int {
  TRACTION_CONTROL_OFF = 0,
  TRACTION_CONTROL_SLIP_CONTROL = 1,
  TRACTION_CONTROL_TORQUE_VECTORING = 2,
  TRACTION_CONTROL_COMPLETE = 3,
  Traction_Control_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Traction_Control_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Traction_Control_IsValid(int value);
constexpr Traction_Control Traction_Control_MIN = TRACTION_CONTROL_OFF;
constexpr Traction_Control Traction_Control_MAX = TRACTION_CONTROL_COMPLETE;
constexpr int Traction_Control_ARRAYSIZE = Traction_Control_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Traction_Control_descriptor();
template<typename T>
inline const std::string& Traction_Control_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Traction_Control>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Traction_Control_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Traction_Control_descriptor(), enum_t_value);
}
inline bool Traction_Control_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Traction_Control* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Traction_Control>(
    Traction_Control_descriptor(), name, value);
}
enum Map : int {
  MAP_R = 0,
  MAP_D20 = 1,
  MAP_D40 = 2,
  MAP_D60 = 3,
  MAP_D80 = 4,
  MAP_D100 = 5,
  Map_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Map_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Map_IsValid(int value);
constexpr Map Map_MIN = MAP_R;
constexpr Map Map_MAX = MAP_D100;
constexpr int Map_ARRAYSIZE = Map_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Map_descriptor();
template<typename T>
inline const std::string& Map_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Map>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Map_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Map_descriptor(), enum_t_value);
}
inline bool Map_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Map* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Map>(
    Map_descriptor(), name, value);
}
enum Car_Status_Set : int {
  CAR_STATUS_SET_IDLE = 0,
  CAR_STATUS_SET_RUN = 1,
  Car_Status_Set_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Car_Status_Set_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Car_Status_Set_IsValid(int value);
constexpr Car_Status_Set Car_Status_Set_MIN = CAR_STATUS_SET_IDLE;
constexpr Car_Status_Set Car_Status_Set_MAX = CAR_STATUS_SET_RUN;
constexpr int Car_Status_Set_ARRAYSIZE = Car_Status_Set_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Car_Status_Set_descriptor();
template<typename T>
inline const std::string& Car_Status_Set_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Car_Status_Set>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Car_Status_Set_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Car_Status_Set_descriptor(), enum_t_value);
}
inline bool Car_Status_Set_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Car_Status_Set* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Car_Status_Set>(
    Car_Status_Set_descriptor(), name, value);
}
enum Bound : int {
  BOUND_SET_MAX = 0,
  BOUND_SET_MIN = 1,
  Bound_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Bound_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Bound_IsValid(int value);
constexpr Bound Bound_MIN = BOUND_SET_MAX;
constexpr Bound Bound_MAX = BOUND_SET_MIN;
constexpr int Bound_ARRAYSIZE = Bound_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Bound_descriptor();
template<typename T>
inline const std::string& Bound_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Bound>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Bound_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Bound_descriptor(), enum_t_value);
}
inline bool Bound_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Bound* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Bound>(
    Bound_descriptor(), name, value);
}
enum Pedal : int {
  PEDAL_ACCELERATOR = 0,
  PEDAL_BRAKE = 1,
  Pedal_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Pedal_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Pedal_IsValid(int value);
constexpr Pedal Pedal_MIN = PEDAL_ACCELERATOR;
constexpr Pedal Pedal_MAX = PEDAL_BRAKE;
constexpr int Pedal_ARRAYSIZE = Pedal_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Pedal_descriptor();
template<typename T>
inline const std::string& Pedal_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Pedal>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Pedal_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Pedal_descriptor(), enum_t_value);
}
inline bool Pedal_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Pedal* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Pedal>(
    Pedal_descriptor(), name, value);
}
enum Balancing_Status : int {
  BALANCING_STATUS_ON = 0,
  BALANCING_STATUS_OFF = 1,
  Balancing_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Balancing_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Balancing_Status_IsValid(int value);
constexpr Balancing_Status Balancing_Status_MIN = BALANCING_STATUS_ON;
constexpr Balancing_Status Balancing_Status_MAX = BALANCING_STATUS_OFF;
constexpr int Balancing_Status_ARRAYSIZE = Balancing_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Balancing_Status_descriptor();
template<typename T>
inline const std::string& Balancing_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Balancing_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Balancing_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Balancing_Status_descriptor(), enum_t_value);
}
inline bool Balancing_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Balancing_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Balancing_Status>(
    Balancing_Status_descriptor(), name, value);
}
// ===================================================================

class STEER_VERSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.STEER_VERSION) */ {
 public:
  inline STEER_VERSION() : STEER_VERSION(nullptr) {}
  ~STEER_VERSION() override;
  explicit constexpr STEER_VERSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STEER_VERSION(const STEER_VERSION& from);
  STEER_VERSION(STEER_VERSION&& from) noexcept
    : STEER_VERSION() {
    *this = ::std::move(from);
  }

  inline STEER_VERSION& operator=(const STEER_VERSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline STEER_VERSION& operator=(STEER_VERSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STEER_VERSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const STEER_VERSION* internal_default_instance() {
    return reinterpret_cast<const STEER_VERSION*>(
               &_STEER_VERSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(STEER_VERSION& a, STEER_VERSION& b) {
    a.Swap(&b);
  }
  inline void Swap(STEER_VERSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STEER_VERSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STEER_VERSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STEER_VERSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STEER_VERSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const STEER_VERSION& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STEER_VERSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.STEER_VERSION";
  }
  protected:
  explicit STEER_VERSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.STEER_VERSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class DAS_VERSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.DAS_VERSION) */ {
 public:
  inline DAS_VERSION() : DAS_VERSION(nullptr) {}
  ~DAS_VERSION() override;
  explicit constexpr DAS_VERSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DAS_VERSION(const DAS_VERSION& from);
  DAS_VERSION(DAS_VERSION&& from) noexcept
    : DAS_VERSION() {
    *this = ::std::move(from);
  }

  inline DAS_VERSION& operator=(const DAS_VERSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline DAS_VERSION& operator=(DAS_VERSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DAS_VERSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const DAS_VERSION* internal_default_instance() {
    return reinterpret_cast<const DAS_VERSION*>(
               &_DAS_VERSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DAS_VERSION& a, DAS_VERSION& b) {
    a.Swap(&b);
  }
  inline void Swap(DAS_VERSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DAS_VERSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DAS_VERSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DAS_VERSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DAS_VERSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DAS_VERSION& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DAS_VERSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.DAS_VERSION";
  }
  protected:
  explicit DAS_VERSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.DAS_VERSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_VERSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_VERSION) */ {
 public:
  inline HV_VERSION() : HV_VERSION(nullptr) {}
  ~HV_VERSION() override;
  explicit constexpr HV_VERSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_VERSION(const HV_VERSION& from);
  HV_VERSION(HV_VERSION&& from) noexcept
    : HV_VERSION() {
    *this = ::std::move(from);
  }

  inline HV_VERSION& operator=(const HV_VERSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_VERSION& operator=(HV_VERSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_VERSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_VERSION* internal_default_instance() {
    return reinterpret_cast<const HV_VERSION*>(
               &_HV_VERSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HV_VERSION& a, HV_VERSION& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_VERSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_VERSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_VERSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_VERSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_VERSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_VERSION& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_VERSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_VERSION";
  }
  protected:
  explicit HV_VERSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_VERSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LV_VERSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LV_VERSION) */ {
 public:
  inline LV_VERSION() : LV_VERSION(nullptr) {}
  ~LV_VERSION() override;
  explicit constexpr LV_VERSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LV_VERSION(const LV_VERSION& from);
  LV_VERSION(LV_VERSION&& from) noexcept
    : LV_VERSION() {
    *this = ::std::move(from);
  }

  inline LV_VERSION& operator=(const LV_VERSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline LV_VERSION& operator=(LV_VERSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LV_VERSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const LV_VERSION* internal_default_instance() {
    return reinterpret_cast<const LV_VERSION*>(
               &_LV_VERSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LV_VERSION& a, LV_VERSION& b) {
    a.Swap(&b);
  }
  inline void Swap(LV_VERSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LV_VERSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LV_VERSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LV_VERSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LV_VERSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LV_VERSION& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LV_VERSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LV_VERSION";
  }
  protected:
  explicit LV_VERSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LV_VERSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TLM_VERSION final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TLM_VERSION) */ {
 public:
  inline TLM_VERSION() : TLM_VERSION(nullptr) {}
  ~TLM_VERSION() override;
  explicit constexpr TLM_VERSION(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TLM_VERSION(const TLM_VERSION& from);
  TLM_VERSION(TLM_VERSION&& from) noexcept
    : TLM_VERSION() {
    *this = ::std::move(from);
  }

  inline TLM_VERSION& operator=(const TLM_VERSION& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLM_VERSION& operator=(TLM_VERSION&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TLM_VERSION& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLM_VERSION* internal_default_instance() {
    return reinterpret_cast<const TLM_VERSION*>(
               &_TLM_VERSION_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TLM_VERSION& a, TLM_VERSION& b) {
    a.Swap(&b);
  }
  inline void Swap(TLM_VERSION* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLM_VERSION* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLM_VERSION* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TLM_VERSION>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TLM_VERSION& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TLM_VERSION& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TLM_VERSION* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TLM_VERSION";
  }
  protected:
  explicit TLM_VERSION(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TLM_VERSION)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TIMESTAMP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TIMESTAMP) */ {
 public:
  inline TIMESTAMP() : TIMESTAMP(nullptr) {}
  ~TIMESTAMP() override;
  explicit constexpr TIMESTAMP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TIMESTAMP(const TIMESTAMP& from);
  TIMESTAMP(TIMESTAMP&& from) noexcept
    : TIMESTAMP() {
    *this = ::std::move(from);
  }

  inline TIMESTAMP& operator=(const TIMESTAMP& from) {
    CopyFrom(from);
    return *this;
  }
  inline TIMESTAMP& operator=(TIMESTAMP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TIMESTAMP& default_instance() {
    return *internal_default_instance();
  }
  static inline const TIMESTAMP* internal_default_instance() {
    return reinterpret_cast<const TIMESTAMP*>(
               &_TIMESTAMP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TIMESTAMP& a, TIMESTAMP& b) {
    a.Swap(&b);
  }
  inline void Swap(TIMESTAMP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TIMESTAMP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TIMESTAMP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TIMESTAMP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TIMESTAMP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TIMESTAMP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TIMESTAMP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TIMESTAMP";
  }
  protected:
  explicit TIMESTAMP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint32 timestamp = 1;
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TIMESTAMP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SET_TLM_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SET_TLM_STATUS) */ {
 public:
  inline SET_TLM_STATUS() : SET_TLM_STATUS(nullptr) {}
  ~SET_TLM_STATUS() override;
  explicit constexpr SET_TLM_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SET_TLM_STATUS(const SET_TLM_STATUS& from);
  SET_TLM_STATUS(SET_TLM_STATUS&& from) noexcept
    : SET_TLM_STATUS() {
    *this = ::std::move(from);
  }

  inline SET_TLM_STATUS& operator=(const SET_TLM_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SET_TLM_STATUS& operator=(SET_TLM_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SET_TLM_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SET_TLM_STATUS* internal_default_instance() {
    return reinterpret_cast<const SET_TLM_STATUS*>(
               &_SET_TLM_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SET_TLM_STATUS& a, SET_TLM_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(SET_TLM_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SET_TLM_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SET_TLM_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SET_TLM_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SET_TLM_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SET_TLM_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SET_TLM_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SET_TLM_STATUS";
  }
  protected:
  explicit SET_TLM_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTlmStatusSetFieldNumber = 1,
    kRaceTypeFieldNumber = 2,
    kDriverFieldNumber = 3,
    kCircuitFieldNumber = 4,
  };
  // .primary.Tlm_Status_Set tlm_status_set = 1;
  void clear_tlm_status_set();
  ::primary::Tlm_Status_Set tlm_status_set() const;
  void set_tlm_status_set(::primary::Tlm_Status_Set value);
  private:
  ::primary::Tlm_Status_Set _internal_tlm_status_set() const;
  void _internal_set_tlm_status_set(::primary::Tlm_Status_Set value);
  public:

  // .primary.Race_Type race_type = 2;
  void clear_race_type();
  ::primary::Race_Type race_type() const;
  void set_race_type(::primary::Race_Type value);
  private:
  ::primary::Race_Type _internal_race_type() const;
  void _internal_set_race_type(::primary::Race_Type value);
  public:

  // uint32 driver = 3;
  void clear_driver();
  uint32_t driver() const;
  void set_driver(uint32_t value);
  private:
  uint32_t _internal_driver() const;
  void _internal_set_driver(uint32_t value);
  public:

  // uint32 circuit = 4;
  void clear_circuit();
  uint32_t circuit() const;
  void set_circuit(uint32_t value);
  private:
  uint32_t _internal_circuit() const;
  void _internal_set_circuit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SET_TLM_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int tlm_status_set_;
  int race_type_;
  uint32_t driver_;
  uint32_t circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class STEER_SYSTEM_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.STEER_SYSTEM_STATUS) */ {
 public:
  inline STEER_SYSTEM_STATUS() : STEER_SYSTEM_STATUS(nullptr) {}
  ~STEER_SYSTEM_STATUS() override;
  explicit constexpr STEER_SYSTEM_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STEER_SYSTEM_STATUS(const STEER_SYSTEM_STATUS& from);
  STEER_SYSTEM_STATUS(STEER_SYSTEM_STATUS&& from) noexcept
    : STEER_SYSTEM_STATUS() {
    *this = ::std::move(from);
  }

  inline STEER_SYSTEM_STATUS& operator=(const STEER_SYSTEM_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline STEER_SYSTEM_STATUS& operator=(STEER_SYSTEM_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STEER_SYSTEM_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const STEER_SYSTEM_STATUS* internal_default_instance() {
    return reinterpret_cast<const STEER_SYSTEM_STATUS*>(
               &_STEER_SYSTEM_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(STEER_SYSTEM_STATUS& a, STEER_SYSTEM_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(STEER_SYSTEM_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STEER_SYSTEM_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STEER_SYSTEM_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STEER_SYSTEM_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STEER_SYSTEM_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const STEER_SYSTEM_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STEER_SYSTEM_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.STEER_SYSTEM_STATUS";
  }
  protected:
  explicit STEER_SYSTEM_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocTempFieldNumber = 1,
  };
  // uint32 soc_temp = 1;
  void clear_soc_temp();
  uint32_t soc_temp() const;
  void set_soc_temp(uint32_t value);
  private:
  uint32_t _internal_soc_temp() const;
  void _internal_set_soc_temp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.STEER_SYSTEM_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t soc_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TLM_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TLM_STATUS) */ {
 public:
  inline TLM_STATUS() : TLM_STATUS(nullptr) {}
  ~TLM_STATUS() override;
  explicit constexpr TLM_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TLM_STATUS(const TLM_STATUS& from);
  TLM_STATUS(TLM_STATUS&& from) noexcept
    : TLM_STATUS() {
    *this = ::std::move(from);
  }

  inline TLM_STATUS& operator=(const TLM_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLM_STATUS& operator=(TLM_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TLM_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLM_STATUS* internal_default_instance() {
    return reinterpret_cast<const TLM_STATUS*>(
               &_TLM_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TLM_STATUS& a, TLM_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(TLM_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLM_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLM_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TLM_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TLM_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TLM_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TLM_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TLM_STATUS";
  }
  protected:
  explicit TLM_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTlmStatusFieldNumber = 1,
    kRaceTypeFieldNumber = 2,
    kDriverFieldNumber = 3,
    kCircuitFieldNumber = 4,
  };
  // .primary.Tlm_Status tlm_status = 1;
  void clear_tlm_status();
  ::primary::Tlm_Status tlm_status() const;
  void set_tlm_status(::primary::Tlm_Status value);
  private:
  ::primary::Tlm_Status _internal_tlm_status() const;
  void _internal_set_tlm_status(::primary::Tlm_Status value);
  public:

  // .primary.Race_Type race_type = 2;
  void clear_race_type();
  ::primary::Race_Type race_type() const;
  void set_race_type(::primary::Race_Type value);
  private:
  ::primary::Race_Type _internal_race_type() const;
  void _internal_set_race_type(::primary::Race_Type value);
  public:

  // uint32 driver = 3;
  void clear_driver();
  uint32_t driver() const;
  void set_driver(uint32_t value);
  private:
  uint32_t _internal_driver() const;
  void _internal_set_driver(uint32_t value);
  public:

  // uint32 circuit = 4;
  void clear_circuit();
  uint32_t circuit() const;
  void set_circuit(uint32_t value);
  private:
  uint32_t _internal_circuit() const;
  void _internal_set_circuit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TLM_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int tlm_status_;
  int race_type_;
  uint32_t driver_;
  uint32_t circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class CAR_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.CAR_STATUS) */ {
 public:
  inline CAR_STATUS() : CAR_STATUS(nullptr) {}
  ~CAR_STATUS() override;
  explicit constexpr CAR_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAR_STATUS(const CAR_STATUS& from);
  CAR_STATUS(CAR_STATUS&& from) noexcept
    : CAR_STATUS() {
    *this = ::std::move(from);
  }

  inline CAR_STATUS& operator=(const CAR_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAR_STATUS& operator=(CAR_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAR_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAR_STATUS* internal_default_instance() {
    return reinterpret_cast<const CAR_STATUS*>(
               &_CAR_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CAR_STATUS& a, CAR_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(CAR_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAR_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAR_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAR_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAR_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAR_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAR_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.CAR_STATUS";
  }
  protected:
  explicit CAR_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInverterLFieldNumber = 1,
    kInverterRFieldNumber = 2,
    kCarStatusFieldNumber = 3,
  };
  // .primary.Inverter_Status inverter_l = 1;
  void clear_inverter_l();
  ::primary::Inverter_Status inverter_l() const;
  void set_inverter_l(::primary::Inverter_Status value);
  private:
  ::primary::Inverter_Status _internal_inverter_l() const;
  void _internal_set_inverter_l(::primary::Inverter_Status value);
  public:

  // .primary.Inverter_Status inverter_r = 2;
  void clear_inverter_r();
  ::primary::Inverter_Status inverter_r() const;
  void set_inverter_r(::primary::Inverter_Status value);
  private:
  ::primary::Inverter_Status _internal_inverter_r() const;
  void _internal_set_inverter_r(::primary::Inverter_Status value);
  public:

  // .primary.Car_Status car_status = 3;
  void clear_car_status();
  ::primary::Car_Status car_status() const;
  void set_car_status(::primary::Car_Status value);
  private:
  ::primary::Car_Status _internal_car_status() const;
  void _internal_set_car_status(::primary::Car_Status value);
  public:

  // @@protoc_insertion_point(class_scope:primary.CAR_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int inverter_l_;
  int inverter_r_;
  int car_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SPEED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SPEED) */ {
 public:
  inline SPEED() : SPEED(nullptr) {}
  ~SPEED() override;
  explicit constexpr SPEED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPEED(const SPEED& from);
  SPEED(SPEED&& from) noexcept
    : SPEED() {
    *this = ::std::move(from);
  }

  inline SPEED& operator=(const SPEED& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPEED& operator=(SPEED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPEED& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPEED* internal_default_instance() {
    return reinterpret_cast<const SPEED*>(
               &_SPEED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SPEED& a, SPEED& b) {
    a.Swap(&b);
  }
  inline void Swap(SPEED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPEED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPEED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPEED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPEED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SPEED& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPEED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SPEED";
  }
  protected:
  explicit SPEED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderRFieldNumber = 1,
    kEncoderLFieldNumber = 2,
    kInverterRFieldNumber = 3,
    kInverterLFieldNumber = 4,
  };
  // uint32 encoder_r = 1;
  void clear_encoder_r();
  uint32_t encoder_r() const;
  void set_encoder_r(uint32_t value);
  private:
  uint32_t _internal_encoder_r() const;
  void _internal_set_encoder_r(uint32_t value);
  public:

  // uint32 encoder_l = 2;
  void clear_encoder_l();
  uint32_t encoder_l() const;
  void set_encoder_l(uint32_t value);
  private:
  uint32_t _internal_encoder_l() const;
  void _internal_set_encoder_l(uint32_t value);
  public:

  // uint32 inverter_r = 3;
  void clear_inverter_r();
  uint32_t inverter_r() const;
  void set_inverter_r(uint32_t value);
  private:
  uint32_t _internal_inverter_r() const;
  void _internal_set_inverter_r(uint32_t value);
  public:

  // uint32 inverter_l = 4;
  void clear_inverter_l();
  uint32_t inverter_l() const;
  void set_inverter_l(uint32_t value);
  private:
  uint32_t _internal_inverter_l() const;
  void _internal_set_inverter_l(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SPEED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t encoder_r_;
  uint32_t encoder_l_;
  uint32_t inverter_r_;
  uint32_t inverter_l_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_VOLTAGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_VOLTAGE) */ {
 public:
  inline HV_VOLTAGE() : HV_VOLTAGE(nullptr) {}
  ~HV_VOLTAGE() override;
  explicit constexpr HV_VOLTAGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_VOLTAGE(const HV_VOLTAGE& from);
  HV_VOLTAGE(HV_VOLTAGE&& from) noexcept
    : HV_VOLTAGE() {
    *this = ::std::move(from);
  }

  inline HV_VOLTAGE& operator=(const HV_VOLTAGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_VOLTAGE& operator=(HV_VOLTAGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_VOLTAGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_VOLTAGE* internal_default_instance() {
    return reinterpret_cast<const HV_VOLTAGE*>(
               &_HV_VOLTAGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HV_VOLTAGE& a, HV_VOLTAGE& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_VOLTAGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_VOLTAGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_VOLTAGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_VOLTAGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_VOLTAGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_VOLTAGE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_VOLTAGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_VOLTAGE";
  }
  protected:
  explicit HV_VOLTAGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackVoltageFieldNumber = 1,
    kBusVoltageFieldNumber = 2,
    kMaxCellVoltageFieldNumber = 3,
    kMinCellVoltageFieldNumber = 4,
  };
  // uint32 pack_voltage = 1;
  void clear_pack_voltage();
  uint32_t pack_voltage() const;
  void set_pack_voltage(uint32_t value);
  private:
  uint32_t _internal_pack_voltage() const;
  void _internal_set_pack_voltage(uint32_t value);
  public:

  // uint32 bus_voltage = 2;
  void clear_bus_voltage();
  uint32_t bus_voltage() const;
  void set_bus_voltage(uint32_t value);
  private:
  uint32_t _internal_bus_voltage() const;
  void _internal_set_bus_voltage(uint32_t value);
  public:

  // uint32 max_cell_voltage = 3;
  void clear_max_cell_voltage();
  uint32_t max_cell_voltage() const;
  void set_max_cell_voltage(uint32_t value);
  private:
  uint32_t _internal_max_cell_voltage() const;
  void _internal_set_max_cell_voltage(uint32_t value);
  public:

  // uint32 min_cell_voltage = 4;
  void clear_min_cell_voltage();
  uint32_t min_cell_voltage() const;
  void set_min_cell_voltage(uint32_t value);
  private:
  uint32_t _internal_min_cell_voltage() const;
  void _internal_set_min_cell_voltage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_VOLTAGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t pack_voltage_;
  uint32_t bus_voltage_;
  uint32_t max_cell_voltage_;
  uint32_t min_cell_voltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_CURRENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_CURRENT) */ {
 public:
  inline HV_CURRENT() : HV_CURRENT(nullptr) {}
  ~HV_CURRENT() override;
  explicit constexpr HV_CURRENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_CURRENT(const HV_CURRENT& from);
  HV_CURRENT(HV_CURRENT&& from) noexcept
    : HV_CURRENT() {
    *this = ::std::move(from);
  }

  inline HV_CURRENT& operator=(const HV_CURRENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_CURRENT& operator=(HV_CURRENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_CURRENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_CURRENT* internal_default_instance() {
    return reinterpret_cast<const HV_CURRENT*>(
               &_HV_CURRENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HV_CURRENT& a, HV_CURRENT& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_CURRENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_CURRENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_CURRENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_CURRENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_CURRENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_CURRENT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_CURRENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_CURRENT";
  }
  protected:
  explicit HV_CURRENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kPowerFieldNumber = 2,
  };
  // uint32 current = 1;
  void clear_current();
  uint32_t current() const;
  void set_current(uint32_t value);
  private:
  uint32_t _internal_current() const;
  void _internal_set_current(uint32_t value);
  public:

  // int32 power = 2;
  void clear_power();
  int32_t power() const;
  void set_power(int32_t value);
  private:
  int32_t _internal_power() const;
  void _internal_set_power(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_CURRENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t current_;
  int32_t power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_TEMP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_TEMP) */ {
 public:
  inline HV_TEMP() : HV_TEMP(nullptr) {}
  ~HV_TEMP() override;
  explicit constexpr HV_TEMP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_TEMP(const HV_TEMP& from);
  HV_TEMP(HV_TEMP&& from) noexcept
    : HV_TEMP() {
    *this = ::std::move(from);
  }

  inline HV_TEMP& operator=(const HV_TEMP& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_TEMP& operator=(HV_TEMP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_TEMP& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_TEMP* internal_default_instance() {
    return reinterpret_cast<const HV_TEMP*>(
               &_HV_TEMP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HV_TEMP& a, HV_TEMP& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_TEMP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_TEMP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_TEMP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_TEMP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_TEMP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_TEMP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_TEMP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_TEMP";
  }
  protected:
  explicit HV_TEMP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAverageTempFieldNumber = 1,
    kMaxTempFieldNumber = 2,
    kMinTempFieldNumber = 3,
  };
  // uint32 average_temp = 1;
  void clear_average_temp();
  uint32_t average_temp() const;
  void set_average_temp(uint32_t value);
  private:
  uint32_t _internal_average_temp() const;
  void _internal_set_average_temp(uint32_t value);
  public:

  // uint32 max_temp = 2;
  void clear_max_temp();
  uint32_t max_temp() const;
  void set_max_temp(uint32_t value);
  private:
  uint32_t _internal_max_temp() const;
  void _internal_set_max_temp(uint32_t value);
  public:

  // uint32 min_temp = 3;
  void clear_min_temp();
  uint32_t min_temp() const;
  void set_min_temp(uint32_t value);
  private:
  uint32_t _internal_min_temp() const;
  void _internal_set_min_temp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_TEMP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t average_temp_;
  uint32_t max_temp_;
  uint32_t min_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_ERRORS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_ERRORS) */ {
 public:
  inline HV_ERRORS() : HV_ERRORS(nullptr) {}
  ~HV_ERRORS() override;
  explicit constexpr HV_ERRORS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_ERRORS(const HV_ERRORS& from);
  HV_ERRORS(HV_ERRORS&& from) noexcept
    : HV_ERRORS() {
    *this = ::std::move(from);
  }

  inline HV_ERRORS& operator=(const HV_ERRORS& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_ERRORS& operator=(HV_ERRORS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_ERRORS& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_ERRORS* internal_default_instance() {
    return reinterpret_cast<const HV_ERRORS*>(
               &_HV_ERRORS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HV_ERRORS& a, HV_ERRORS& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_ERRORS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_ERRORS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_ERRORS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_ERRORS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_ERRORS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_ERRORS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_ERRORS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_ERRORS";
  }
  protected:
  explicit HV_ERRORS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 1,
    kErrorsFieldNumber = 2,
  };
  // uint32 warnings = 1;
  void clear_warnings();
  uint32_t warnings() const;
  void set_warnings(uint32_t value);
  private:
  uint32_t _internal_warnings() const;
  void _internal_set_warnings(uint32_t value);
  public:

  // uint32 errors = 2;
  void clear_errors();
  uint32_t errors() const;
  void set_errors(uint32_t value);
  private:
  uint32_t _internal_errors() const;
  void _internal_set_errors(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_ERRORS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t warnings_;
  uint32_t errors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TS_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TS_STATUS) */ {
 public:
  inline TS_STATUS() : TS_STATUS(nullptr) {}
  ~TS_STATUS() override;
  explicit constexpr TS_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TS_STATUS(const TS_STATUS& from);
  TS_STATUS(TS_STATUS&& from) noexcept
    : TS_STATUS() {
    *this = ::std::move(from);
  }

  inline TS_STATUS& operator=(const TS_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline TS_STATUS& operator=(TS_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TS_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const TS_STATUS* internal_default_instance() {
    return reinterpret_cast<const TS_STATUS*>(
               &_TS_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TS_STATUS& a, TS_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(TS_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TS_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TS_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TS_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TS_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TS_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TS_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TS_STATUS";
  }
  protected:
  explicit TS_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsStatusFieldNumber = 1,
  };
  // .primary.Ts_Status ts_status = 1;
  void clear_ts_status();
  ::primary::Ts_Status ts_status() const;
  void set_ts_status(::primary::Ts_Status value);
  private:
  ::primary::Ts_Status _internal_ts_status() const;
  void _internal_set_ts_status(::primary::Ts_Status value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TS_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int ts_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SET_TS_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SET_TS_STATUS) */ {
 public:
  inline SET_TS_STATUS() : SET_TS_STATUS(nullptr) {}
  ~SET_TS_STATUS() override;
  explicit constexpr SET_TS_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SET_TS_STATUS(const SET_TS_STATUS& from);
  SET_TS_STATUS(SET_TS_STATUS&& from) noexcept
    : SET_TS_STATUS() {
    *this = ::std::move(from);
  }

  inline SET_TS_STATUS& operator=(const SET_TS_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SET_TS_STATUS& operator=(SET_TS_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SET_TS_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SET_TS_STATUS* internal_default_instance() {
    return reinterpret_cast<const SET_TS_STATUS*>(
               &_SET_TS_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SET_TS_STATUS& a, SET_TS_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(SET_TS_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SET_TS_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SET_TS_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SET_TS_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SET_TS_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SET_TS_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SET_TS_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SET_TS_STATUS";
  }
  protected:
  explicit SET_TS_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsStatusSetFieldNumber = 1,
  };
  // .primary.Ts_Status_Set ts_status_set = 1;
  void clear_ts_status_set();
  ::primary::Ts_Status_Set ts_status_set() const;
  void set_ts_status_set(::primary::Ts_Status_Set value);
  private:
  ::primary::Ts_Status_Set _internal_ts_status_set() const;
  void _internal_set_ts_status_set(::primary::Ts_Status_Set value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SET_TS_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int ts_status_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SET_CELL_BALANCING_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SET_CELL_BALANCING_STATUS) */ {
 public:
  inline SET_CELL_BALANCING_STATUS() : SET_CELL_BALANCING_STATUS(nullptr) {}
  ~SET_CELL_BALANCING_STATUS() override;
  explicit constexpr SET_CELL_BALANCING_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SET_CELL_BALANCING_STATUS(const SET_CELL_BALANCING_STATUS& from);
  SET_CELL_BALANCING_STATUS(SET_CELL_BALANCING_STATUS&& from) noexcept
    : SET_CELL_BALANCING_STATUS() {
    *this = ::std::move(from);
  }

  inline SET_CELL_BALANCING_STATUS& operator=(const SET_CELL_BALANCING_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SET_CELL_BALANCING_STATUS& operator=(SET_CELL_BALANCING_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SET_CELL_BALANCING_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SET_CELL_BALANCING_STATUS* internal_default_instance() {
    return reinterpret_cast<const SET_CELL_BALANCING_STATUS*>(
               &_SET_CELL_BALANCING_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SET_CELL_BALANCING_STATUS& a, SET_CELL_BALANCING_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(SET_CELL_BALANCING_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SET_CELL_BALANCING_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SET_CELL_BALANCING_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SET_CELL_BALANCING_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SET_CELL_BALANCING_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SET_CELL_BALANCING_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SET_CELL_BALANCING_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SET_CELL_BALANCING_STATUS";
  }
  protected:
  explicit SET_CELL_BALANCING_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetBalancingStatusFieldNumber = 1,
  };
  // .primary.Set_Balancing_Status set_balancing_status = 1;
  void clear_set_balancing_status();
  ::primary::Set_Balancing_Status set_balancing_status() const;
  void set_set_balancing_status(::primary::Set_Balancing_Status value);
  private:
  ::primary::Set_Balancing_Status _internal_set_balancing_status() const;
  void _internal_set_set_balancing_status(::primary::Set_Balancing_Status value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SET_CELL_BALANCING_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int set_balancing_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HANDCART_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HANDCART_STATUS) */ {
 public:
  inline HANDCART_STATUS() : HANDCART_STATUS(nullptr) {}
  ~HANDCART_STATUS() override;
  explicit constexpr HANDCART_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HANDCART_STATUS(const HANDCART_STATUS& from);
  HANDCART_STATUS(HANDCART_STATUS&& from) noexcept
    : HANDCART_STATUS() {
    *this = ::std::move(from);
  }

  inline HANDCART_STATUS& operator=(const HANDCART_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline HANDCART_STATUS& operator=(HANDCART_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HANDCART_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const HANDCART_STATUS* internal_default_instance() {
    return reinterpret_cast<const HANDCART_STATUS*>(
               &_HANDCART_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HANDCART_STATUS& a, HANDCART_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(HANDCART_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HANDCART_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HANDCART_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HANDCART_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HANDCART_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HANDCART_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HANDCART_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HANDCART_STATUS";
  }
  protected:
  explicit HANDCART_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HANDCART_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool connected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class STEER_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.STEER_STATUS) */ {
 public:
  inline STEER_STATUS() : STEER_STATUS(nullptr) {}
  ~STEER_STATUS() override;
  explicit constexpr STEER_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  STEER_STATUS(const STEER_STATUS& from);
  STEER_STATUS(STEER_STATUS&& from) noexcept
    : STEER_STATUS() {
    *this = ::std::move(from);
  }

  inline STEER_STATUS& operator=(const STEER_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline STEER_STATUS& operator=(STEER_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const STEER_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const STEER_STATUS* internal_default_instance() {
    return reinterpret_cast<const STEER_STATUS*>(
               &_STEER_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(STEER_STATUS& a, STEER_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(STEER_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(STEER_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  STEER_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<STEER_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const STEER_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const STEER_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(STEER_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.STEER_STATUS";
  }
  protected:
  explicit STEER_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTractionControlFieldNumber = 1,
    kMapFieldNumber = 2,
  };
  // .primary.Traction_Control traction_control = 1;
  void clear_traction_control();
  ::primary::Traction_Control traction_control() const;
  void set_traction_control(::primary::Traction_Control value);
  private:
  ::primary::Traction_Control _internal_traction_control() const;
  void _internal_set_traction_control(::primary::Traction_Control value);
  public:

  // .primary.Map map = 2;
  void clear_map();
  ::primary::Map map() const;
  void set_map(::primary::Map value);
  private:
  ::primary::Map _internal_map() const;
  void _internal_set_map(::primary::Map value);
  public:

  // @@protoc_insertion_point(class_scope:primary.STEER_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int traction_control_;
  int map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SET_CAR_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SET_CAR_STATUS) */ {
 public:
  inline SET_CAR_STATUS() : SET_CAR_STATUS(nullptr) {}
  ~SET_CAR_STATUS() override;
  explicit constexpr SET_CAR_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SET_CAR_STATUS(const SET_CAR_STATUS& from);
  SET_CAR_STATUS(SET_CAR_STATUS&& from) noexcept
    : SET_CAR_STATUS() {
    *this = ::std::move(from);
  }

  inline SET_CAR_STATUS& operator=(const SET_CAR_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SET_CAR_STATUS& operator=(SET_CAR_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SET_CAR_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SET_CAR_STATUS* internal_default_instance() {
    return reinterpret_cast<const SET_CAR_STATUS*>(
               &_SET_CAR_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SET_CAR_STATUS& a, SET_CAR_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(SET_CAR_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SET_CAR_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SET_CAR_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SET_CAR_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SET_CAR_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SET_CAR_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SET_CAR_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SET_CAR_STATUS";
  }
  protected:
  explicit SET_CAR_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarStatusSetFieldNumber = 1,
  };
  // .primary.Car_Status_Set car_status_set = 1;
  void clear_car_status_set();
  ::primary::Car_Status_Set car_status_set() const;
  void set_car_status_set(::primary::Car_Status_Set value);
  private:
  ::primary::Car_Status_Set _internal_car_status_set() const;
  void _internal_set_car_status_set(::primary::Car_Status_Set value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SET_CAR_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int car_status_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SET_PEDALS_RANGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SET_PEDALS_RANGE) */ {
 public:
  inline SET_PEDALS_RANGE() : SET_PEDALS_RANGE(nullptr) {}
  ~SET_PEDALS_RANGE() override;
  explicit constexpr SET_PEDALS_RANGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SET_PEDALS_RANGE(const SET_PEDALS_RANGE& from);
  SET_PEDALS_RANGE(SET_PEDALS_RANGE&& from) noexcept
    : SET_PEDALS_RANGE() {
    *this = ::std::move(from);
  }

  inline SET_PEDALS_RANGE& operator=(const SET_PEDALS_RANGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline SET_PEDALS_RANGE& operator=(SET_PEDALS_RANGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SET_PEDALS_RANGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const SET_PEDALS_RANGE* internal_default_instance() {
    return reinterpret_cast<const SET_PEDALS_RANGE*>(
               &_SET_PEDALS_RANGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SET_PEDALS_RANGE& a, SET_PEDALS_RANGE& b) {
    a.Swap(&b);
  }
  inline void Swap(SET_PEDALS_RANGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SET_PEDALS_RANGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SET_PEDALS_RANGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SET_PEDALS_RANGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SET_PEDALS_RANGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SET_PEDALS_RANGE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SET_PEDALS_RANGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SET_PEDALS_RANGE";
  }
  protected:
  explicit SET_PEDALS_RANGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundFieldNumber = 1,
    kPedalFieldNumber = 2,
  };
  // .primary.Bound bound = 1;
  void clear_bound();
  ::primary::Bound bound() const;
  void set_bound(::primary::Bound value);
  private:
  ::primary::Bound _internal_bound() const;
  void _internal_set_bound(::primary::Bound value);
  public:

  // .primary.Pedal pedal = 2;
  void clear_pedal();
  ::primary::Pedal pedal() const;
  void set_pedal(::primary::Pedal value);
  private:
  ::primary::Pedal _internal_pedal() const;
  void _internal_set_pedal(::primary::Pedal value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SET_PEDALS_RANGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int bound_;
  int pedal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LV_CURRENT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LV_CURRENT) */ {
 public:
  inline LV_CURRENT() : LV_CURRENT(nullptr) {}
  ~LV_CURRENT() override;
  explicit constexpr LV_CURRENT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LV_CURRENT(const LV_CURRENT& from);
  LV_CURRENT(LV_CURRENT&& from) noexcept
    : LV_CURRENT() {
    *this = ::std::move(from);
  }

  inline LV_CURRENT& operator=(const LV_CURRENT& from) {
    CopyFrom(from);
    return *this;
  }
  inline LV_CURRENT& operator=(LV_CURRENT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LV_CURRENT& default_instance() {
    return *internal_default_instance();
  }
  static inline const LV_CURRENT* internal_default_instance() {
    return reinterpret_cast<const LV_CURRENT*>(
               &_LV_CURRENT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LV_CURRENT& a, LV_CURRENT& b) {
    a.Swap(&b);
  }
  inline void Swap(LV_CURRENT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LV_CURRENT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LV_CURRENT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LV_CURRENT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LV_CURRENT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LV_CURRENT& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LV_CURRENT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LV_CURRENT";
  }
  protected:
  explicit LV_CURRENT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
  };
  // uint32 current = 1;
  void clear_current();
  uint32_t current() const;
  void set_current(uint32_t value);
  private:
  uint32_t _internal_current() const;
  void _internal_set_current(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LV_CURRENT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t current_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LV_VOLTAGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LV_VOLTAGE) */ {
 public:
  inline LV_VOLTAGE() : LV_VOLTAGE(nullptr) {}
  ~LV_VOLTAGE() override;
  explicit constexpr LV_VOLTAGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LV_VOLTAGE(const LV_VOLTAGE& from);
  LV_VOLTAGE(LV_VOLTAGE&& from) noexcept
    : LV_VOLTAGE() {
    *this = ::std::move(from);
  }

  inline LV_VOLTAGE& operator=(const LV_VOLTAGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline LV_VOLTAGE& operator=(LV_VOLTAGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LV_VOLTAGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const LV_VOLTAGE* internal_default_instance() {
    return reinterpret_cast<const LV_VOLTAGE*>(
               &_LV_VOLTAGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LV_VOLTAGE& a, LV_VOLTAGE& b) {
    a.Swap(&b);
  }
  inline void Swap(LV_VOLTAGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LV_VOLTAGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LV_VOLTAGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LV_VOLTAGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LV_VOLTAGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LV_VOLTAGE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LV_VOLTAGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LV_VOLTAGE";
  }
  protected:
  explicit LV_VOLTAGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalVoltageFieldNumber = 1,
    kVoltage1FieldNumber = 2,
    kVoltage2FieldNumber = 3,
    kVoltage3FieldNumber = 4,
    kVoltage4FieldNumber = 5,
  };
  // uint32 total_voltage = 1;
  void clear_total_voltage();
  uint32_t total_voltage() const;
  void set_total_voltage(uint32_t value);
  private:
  uint32_t _internal_total_voltage() const;
  void _internal_set_total_voltage(uint32_t value);
  public:

  // uint32 voltage_1 = 2;
  void clear_voltage_1();
  uint32_t voltage_1() const;
  void set_voltage_1(uint32_t value);
  private:
  uint32_t _internal_voltage_1() const;
  void _internal_set_voltage_1(uint32_t value);
  public:

  // uint32 voltage_2 = 3;
  void clear_voltage_2();
  uint32_t voltage_2() const;
  void set_voltage_2(uint32_t value);
  private:
  uint32_t _internal_voltage_2() const;
  void _internal_set_voltage_2(uint32_t value);
  public:

  // uint32 voltage_3 = 4;
  void clear_voltage_3();
  uint32_t voltage_3() const;
  void set_voltage_3(uint32_t value);
  private:
  uint32_t _internal_voltage_3() const;
  void _internal_set_voltage_3(uint32_t value);
  public:

  // uint32 voltage_4 = 5;
  void clear_voltage_4();
  uint32_t voltage_4() const;
  void set_voltage_4(uint32_t value);
  private:
  uint32_t _internal_voltage_4() const;
  void _internal_set_voltage_4(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LV_VOLTAGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t total_voltage_;
  uint32_t voltage_1_;
  uint32_t voltage_2_;
  uint32_t voltage_3_;
  uint32_t voltage_4_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LV_TEMPERATURE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LV_TEMPERATURE) */ {
 public:
  inline LV_TEMPERATURE() : LV_TEMPERATURE(nullptr) {}
  ~LV_TEMPERATURE() override;
  explicit constexpr LV_TEMPERATURE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LV_TEMPERATURE(const LV_TEMPERATURE& from);
  LV_TEMPERATURE(LV_TEMPERATURE&& from) noexcept
    : LV_TEMPERATURE() {
    *this = ::std::move(from);
  }

  inline LV_TEMPERATURE& operator=(const LV_TEMPERATURE& from) {
    CopyFrom(from);
    return *this;
  }
  inline LV_TEMPERATURE& operator=(LV_TEMPERATURE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LV_TEMPERATURE& default_instance() {
    return *internal_default_instance();
  }
  static inline const LV_TEMPERATURE* internal_default_instance() {
    return reinterpret_cast<const LV_TEMPERATURE*>(
               &_LV_TEMPERATURE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LV_TEMPERATURE& a, LV_TEMPERATURE& b) {
    a.Swap(&b);
  }
  inline void Swap(LV_TEMPERATURE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LV_TEMPERATURE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LV_TEMPERATURE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LV_TEMPERATURE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LV_TEMPERATURE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LV_TEMPERATURE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LV_TEMPERATURE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LV_TEMPERATURE";
  }
  protected:
  explicit LV_TEMPERATURE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBpTemperatureFieldNumber = 1,
    kDcdcTemperatureFieldNumber = 2,
  };
  // uint32 bp_temperature = 1;
  void clear_bp_temperature();
  uint32_t bp_temperature() const;
  void set_bp_temperature(uint32_t value);
  private:
  uint32_t _internal_bp_temperature() const;
  void _internal_set_bp_temperature(uint32_t value);
  public:

  // uint32 dcdc_temperature = 2;
  void clear_dcdc_temperature();
  uint32_t dcdc_temperature() const;
  void set_dcdc_temperature(uint32_t value);
  private:
  uint32_t _internal_dcdc_temperature() const;
  void _internal_set_dcdc_temperature(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LV_TEMPERATURE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t bp_temperature_;
  uint32_t dcdc_temperature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class COOLING_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.COOLING_STATUS) */ {
 public:
  inline COOLING_STATUS() : COOLING_STATUS(nullptr) {}
  ~COOLING_STATUS() override;
  explicit constexpr COOLING_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  COOLING_STATUS(const COOLING_STATUS& from);
  COOLING_STATUS(COOLING_STATUS&& from) noexcept
    : COOLING_STATUS() {
    *this = ::std::move(from);
  }

  inline COOLING_STATUS& operator=(const COOLING_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline COOLING_STATUS& operator=(COOLING_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const COOLING_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const COOLING_STATUS* internal_default_instance() {
    return reinterpret_cast<const COOLING_STATUS*>(
               &_COOLING_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(COOLING_STATUS& a, COOLING_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(COOLING_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(COOLING_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  COOLING_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<COOLING_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const COOLING_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const COOLING_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(COOLING_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.COOLING_STATUS";
  }
  protected:
  explicit COOLING_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHvFanSpeedFieldNumber = 1,
    kLvFanSpeedFieldNumber = 2,
    kPumpSpeedFieldNumber = 3,
  };
  // uint32 hv_fan_speed = 1;
  void clear_hv_fan_speed();
  uint32_t hv_fan_speed() const;
  void set_hv_fan_speed(uint32_t value);
  private:
  uint32_t _internal_hv_fan_speed() const;
  void _internal_set_hv_fan_speed(uint32_t value);
  public:

  // uint32 lv_fan_speed = 2;
  void clear_lv_fan_speed();
  uint32_t lv_fan_speed() const;
  void set_lv_fan_speed(uint32_t value);
  private:
  uint32_t _internal_lv_fan_speed() const;
  void _internal_set_lv_fan_speed(uint32_t value);
  public:

  // uint32 pump_speed = 3;
  void clear_pump_speed();
  uint32_t pump_speed() const;
  void set_pump_speed(uint32_t value);
  private:
  uint32_t _internal_pump_speed() const;
  void _internal_set_pump_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.COOLING_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t hv_fan_speed_;
  uint32_t lv_fan_speed_;
  uint32_t pump_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_CELLS_VOLTAGE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_CELLS_VOLTAGE) */ {
 public:
  inline HV_CELLS_VOLTAGE() : HV_CELLS_VOLTAGE(nullptr) {}
  ~HV_CELLS_VOLTAGE() override;
  explicit constexpr HV_CELLS_VOLTAGE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_CELLS_VOLTAGE(const HV_CELLS_VOLTAGE& from);
  HV_CELLS_VOLTAGE(HV_CELLS_VOLTAGE&& from) noexcept
    : HV_CELLS_VOLTAGE() {
    *this = ::std::move(from);
  }

  inline HV_CELLS_VOLTAGE& operator=(const HV_CELLS_VOLTAGE& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_CELLS_VOLTAGE& operator=(HV_CELLS_VOLTAGE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_CELLS_VOLTAGE& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_CELLS_VOLTAGE* internal_default_instance() {
    return reinterpret_cast<const HV_CELLS_VOLTAGE*>(
               &_HV_CELLS_VOLTAGE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(HV_CELLS_VOLTAGE& a, HV_CELLS_VOLTAGE& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_CELLS_VOLTAGE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_CELLS_VOLTAGE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_CELLS_VOLTAGE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_CELLS_VOLTAGE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_CELLS_VOLTAGE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_CELLS_VOLTAGE& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_CELLS_VOLTAGE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_CELLS_VOLTAGE";
  }
  protected:
  explicit HV_CELLS_VOLTAGE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIndexFieldNumber = 1,
    kVoltage0FieldNumber = 2,
    kVoltage1FieldNumber = 3,
    kVoltage2FieldNumber = 4,
  };
  // uint32 cell_index = 1;
  void clear_cell_index();
  uint32_t cell_index() const;
  void set_cell_index(uint32_t value);
  private:
  uint32_t _internal_cell_index() const;
  void _internal_set_cell_index(uint32_t value);
  public:

  // uint32 voltage_0 = 2;
  void clear_voltage_0();
  uint32_t voltage_0() const;
  void set_voltage_0(uint32_t value);
  private:
  uint32_t _internal_voltage_0() const;
  void _internal_set_voltage_0(uint32_t value);
  public:

  // uint32 voltage_1 = 3;
  void clear_voltage_1();
  uint32_t voltage_1() const;
  void set_voltage_1(uint32_t value);
  private:
  uint32_t _internal_voltage_1() const;
  void _internal_set_voltage_1(uint32_t value);
  public:

  // uint32 voltage_2 = 4;
  void clear_voltage_2();
  uint32_t voltage_2() const;
  void set_voltage_2(uint32_t value);
  private:
  uint32_t _internal_voltage_2() const;
  void _internal_set_voltage_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_CELLS_VOLTAGE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t cell_index_;
  uint32_t voltage_0_;
  uint32_t voltage_1_;
  uint32_t voltage_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_CELLS_TEMP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_CELLS_TEMP) */ {
 public:
  inline HV_CELLS_TEMP() : HV_CELLS_TEMP(nullptr) {}
  ~HV_CELLS_TEMP() override;
  explicit constexpr HV_CELLS_TEMP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_CELLS_TEMP(const HV_CELLS_TEMP& from);
  HV_CELLS_TEMP(HV_CELLS_TEMP&& from) noexcept
    : HV_CELLS_TEMP() {
    *this = ::std::move(from);
  }

  inline HV_CELLS_TEMP& operator=(const HV_CELLS_TEMP& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_CELLS_TEMP& operator=(HV_CELLS_TEMP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_CELLS_TEMP& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_CELLS_TEMP* internal_default_instance() {
    return reinterpret_cast<const HV_CELLS_TEMP*>(
               &_HV_CELLS_TEMP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(HV_CELLS_TEMP& a, HV_CELLS_TEMP& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_CELLS_TEMP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_CELLS_TEMP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_CELLS_TEMP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_CELLS_TEMP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_CELLS_TEMP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_CELLS_TEMP& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_CELLS_TEMP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_CELLS_TEMP";
  }
  protected:
  explicit HV_CELLS_TEMP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIndexFieldNumber = 1,
    kTemp0FieldNumber = 2,
    kTemp1FieldNumber = 3,
    kTemp2FieldNumber = 4,
    kTemp3FieldNumber = 5,
    kTemp4FieldNumber = 6,
    kTemp5FieldNumber = 7,
    kTemp6FieldNumber = 8,
  };
  // uint32 cell_index = 1;
  void clear_cell_index();
  uint32_t cell_index() const;
  void set_cell_index(uint32_t value);
  private:
  uint32_t _internal_cell_index() const;
  void _internal_set_cell_index(uint32_t value);
  public:

  // uint32 temp_0 = 2;
  void clear_temp_0();
  uint32_t temp_0() const;
  void set_temp_0(uint32_t value);
  private:
  uint32_t _internal_temp_0() const;
  void _internal_set_temp_0(uint32_t value);
  public:

  // uint32 temp_1 = 3;
  void clear_temp_1();
  uint32_t temp_1() const;
  void set_temp_1(uint32_t value);
  private:
  uint32_t _internal_temp_1() const;
  void _internal_set_temp_1(uint32_t value);
  public:

  // uint32 temp_2 = 4;
  void clear_temp_2();
  uint32_t temp_2() const;
  void set_temp_2(uint32_t value);
  private:
  uint32_t _internal_temp_2() const;
  void _internal_set_temp_2(uint32_t value);
  public:

  // uint32 temp_3 = 5;
  void clear_temp_3();
  uint32_t temp_3() const;
  void set_temp_3(uint32_t value);
  private:
  uint32_t _internal_temp_3() const;
  void _internal_set_temp_3(uint32_t value);
  public:

  // uint32 temp_4 = 6;
  void clear_temp_4();
  uint32_t temp_4() const;
  void set_temp_4(uint32_t value);
  private:
  uint32_t _internal_temp_4() const;
  void _internal_set_temp_4(uint32_t value);
  public:

  // uint32 temp_5 = 7;
  void clear_temp_5();
  uint32_t temp_5() const;
  void set_temp_5(uint32_t value);
  private:
  uint32_t _internal_temp_5() const;
  void _internal_set_temp_5(uint32_t value);
  public:

  // uint32 temp_6 = 8;
  void clear_temp_6();
  uint32_t temp_6() const;
  void set_temp_6(uint32_t value);
  private:
  uint32_t _internal_temp_6() const;
  void _internal_set_temp_6(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_CELLS_TEMP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t cell_index_;
  uint32_t temp_0_;
  uint32_t temp_1_;
  uint32_t temp_2_;
  uint32_t temp_3_;
  uint32_t temp_4_;
  uint32_t temp_5_;
  uint32_t temp_6_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HV_CELL_BALANCING_STATUS final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HV_CELL_BALANCING_STATUS) */ {
 public:
  inline HV_CELL_BALANCING_STATUS() : HV_CELL_BALANCING_STATUS(nullptr) {}
  ~HV_CELL_BALANCING_STATUS() override;
  explicit constexpr HV_CELL_BALANCING_STATUS(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HV_CELL_BALANCING_STATUS(const HV_CELL_BALANCING_STATUS& from);
  HV_CELL_BALANCING_STATUS(HV_CELL_BALANCING_STATUS&& from) noexcept
    : HV_CELL_BALANCING_STATUS() {
    *this = ::std::move(from);
  }

  inline HV_CELL_BALANCING_STATUS& operator=(const HV_CELL_BALANCING_STATUS& from) {
    CopyFrom(from);
    return *this;
  }
  inline HV_CELL_BALANCING_STATUS& operator=(HV_CELL_BALANCING_STATUS&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HV_CELL_BALANCING_STATUS& default_instance() {
    return *internal_default_instance();
  }
  static inline const HV_CELL_BALANCING_STATUS* internal_default_instance() {
    return reinterpret_cast<const HV_CELL_BALANCING_STATUS*>(
               &_HV_CELL_BALANCING_STATUS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(HV_CELL_BALANCING_STATUS& a, HV_CELL_BALANCING_STATUS& b) {
    a.Swap(&b);
  }
  inline void Swap(HV_CELL_BALANCING_STATUS* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HV_CELL_BALANCING_STATUS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HV_CELL_BALANCING_STATUS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HV_CELL_BALANCING_STATUS>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HV_CELL_BALANCING_STATUS& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HV_CELL_BALANCING_STATUS& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HV_CELL_BALANCING_STATUS* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HV_CELL_BALANCING_STATUS";
  }
  protected:
  explicit HV_CELL_BALANCING_STATUS(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalancingStatusFieldNumber = 1,
  };
  // .primary.Balancing_Status balancing_status = 1;
  void clear_balancing_status();
  ::primary::Balancing_Status balancing_status() const;
  void set_balancing_status(::primary::Balancing_Status value);
  private:
  ::primary::Balancing_Status _internal_balancing_status() const;
  void _internal_set_balancing_status(::primary::Balancing_Status value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HV_CELL_BALANCING_STATUS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int balancing_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// STEER_VERSION

// uint32 component_version = 1;
inline void STEER_VERSION::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t STEER_VERSION::_internal_component_version() const {
  return component_version_;
}
inline uint32_t STEER_VERSION::component_version() const {
  // @@protoc_insertion_point(field_get:primary.STEER_VERSION.component_version)
  return _internal_component_version();
}
inline void STEER_VERSION::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void STEER_VERSION::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.STEER_VERSION.component_version)
}

// uint32 cancicd_version = 2;
inline void STEER_VERSION::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t STEER_VERSION::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t STEER_VERSION::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.STEER_VERSION.cancicd_version)
  return _internal_cancicd_version();
}
inline void STEER_VERSION::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void STEER_VERSION::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.STEER_VERSION.cancicd_version)
}

// -------------------------------------------------------------------

// DAS_VERSION

// uint32 component_version = 1;
inline void DAS_VERSION::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t DAS_VERSION::_internal_component_version() const {
  return component_version_;
}
inline uint32_t DAS_VERSION::component_version() const {
  // @@protoc_insertion_point(field_get:primary.DAS_VERSION.component_version)
  return _internal_component_version();
}
inline void DAS_VERSION::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void DAS_VERSION::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.DAS_VERSION.component_version)
}

// uint32 cancicd_version = 2;
inline void DAS_VERSION::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t DAS_VERSION::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t DAS_VERSION::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.DAS_VERSION.cancicd_version)
  return _internal_cancicd_version();
}
inline void DAS_VERSION::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void DAS_VERSION::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.DAS_VERSION.cancicd_version)
}

// -------------------------------------------------------------------

// HV_VERSION

// uint32 component_version = 1;
inline void HV_VERSION::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t HV_VERSION::_internal_component_version() const {
  return component_version_;
}
inline uint32_t HV_VERSION::component_version() const {
  // @@protoc_insertion_point(field_get:primary.HV_VERSION.component_version)
  return _internal_component_version();
}
inline void HV_VERSION::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void HV_VERSION::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.HV_VERSION.component_version)
}

// uint32 cancicd_version = 2;
inline void HV_VERSION::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t HV_VERSION::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t HV_VERSION::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.HV_VERSION.cancicd_version)
  return _internal_cancicd_version();
}
inline void HV_VERSION::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void HV_VERSION::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.HV_VERSION.cancicd_version)
}

// -------------------------------------------------------------------

// LV_VERSION

// uint32 component_version = 1;
inline void LV_VERSION::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t LV_VERSION::_internal_component_version() const {
  return component_version_;
}
inline uint32_t LV_VERSION::component_version() const {
  // @@protoc_insertion_point(field_get:primary.LV_VERSION.component_version)
  return _internal_component_version();
}
inline void LV_VERSION::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void LV_VERSION::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.LV_VERSION.component_version)
}

// uint32 cancicd_version = 2;
inline void LV_VERSION::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t LV_VERSION::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t LV_VERSION::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.LV_VERSION.cancicd_version)
  return _internal_cancicd_version();
}
inline void LV_VERSION::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void LV_VERSION::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.LV_VERSION.cancicd_version)
}

// -------------------------------------------------------------------

// TLM_VERSION

// uint32 component_version = 1;
inline void TLM_VERSION::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t TLM_VERSION::_internal_component_version() const {
  return component_version_;
}
inline uint32_t TLM_VERSION::component_version() const {
  // @@protoc_insertion_point(field_get:primary.TLM_VERSION.component_version)
  return _internal_component_version();
}
inline void TLM_VERSION::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void TLM_VERSION::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.TLM_VERSION.component_version)
}

// uint32 cancicd_version = 2;
inline void TLM_VERSION::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t TLM_VERSION::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t TLM_VERSION::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.TLM_VERSION.cancicd_version)
  return _internal_cancicd_version();
}
inline void TLM_VERSION::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void TLM_VERSION::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.TLM_VERSION.cancicd_version)
}

// -------------------------------------------------------------------

// TIMESTAMP

// uint32 timestamp = 1;
inline void TIMESTAMP::clear_timestamp() {
  timestamp_ = 0u;
}
inline uint32_t TIMESTAMP::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t TIMESTAMP::timestamp() const {
  // @@protoc_insertion_point(field_get:primary.TIMESTAMP.timestamp)
  return _internal_timestamp();
}
inline void TIMESTAMP::_internal_set_timestamp(uint32_t value) {
  
  timestamp_ = value;
}
inline void TIMESTAMP::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:primary.TIMESTAMP.timestamp)
}

// -------------------------------------------------------------------

// SET_TLM_STATUS

// .primary.Tlm_Status_Set tlm_status_set = 1;
inline void SET_TLM_STATUS::clear_tlm_status_set() {
  tlm_status_set_ = 0;
}
inline ::primary::Tlm_Status_Set SET_TLM_STATUS::_internal_tlm_status_set() const {
  return static_cast< ::primary::Tlm_Status_Set >(tlm_status_set_);
}
inline ::primary::Tlm_Status_Set SET_TLM_STATUS::tlm_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SET_TLM_STATUS.tlm_status_set)
  return _internal_tlm_status_set();
}
inline void SET_TLM_STATUS::_internal_set_tlm_status_set(::primary::Tlm_Status_Set value) {
  
  tlm_status_set_ = value;
}
inline void SET_TLM_STATUS::set_tlm_status_set(::primary::Tlm_Status_Set value) {
  _internal_set_tlm_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SET_TLM_STATUS.tlm_status_set)
}

// .primary.Race_Type race_type = 2;
inline void SET_TLM_STATUS::clear_race_type() {
  race_type_ = 0;
}
inline ::primary::Race_Type SET_TLM_STATUS::_internal_race_type() const {
  return static_cast< ::primary::Race_Type >(race_type_);
}
inline ::primary::Race_Type SET_TLM_STATUS::race_type() const {
  // @@protoc_insertion_point(field_get:primary.SET_TLM_STATUS.race_type)
  return _internal_race_type();
}
inline void SET_TLM_STATUS::_internal_set_race_type(::primary::Race_Type value) {
  
  race_type_ = value;
}
inline void SET_TLM_STATUS::set_race_type(::primary::Race_Type value) {
  _internal_set_race_type(value);
  // @@protoc_insertion_point(field_set:primary.SET_TLM_STATUS.race_type)
}

// uint32 driver = 3;
inline void SET_TLM_STATUS::clear_driver() {
  driver_ = 0u;
}
inline uint32_t SET_TLM_STATUS::_internal_driver() const {
  return driver_;
}
inline uint32_t SET_TLM_STATUS::driver() const {
  // @@protoc_insertion_point(field_get:primary.SET_TLM_STATUS.driver)
  return _internal_driver();
}
inline void SET_TLM_STATUS::_internal_set_driver(uint32_t value) {
  
  driver_ = value;
}
inline void SET_TLM_STATUS::set_driver(uint32_t value) {
  _internal_set_driver(value);
  // @@protoc_insertion_point(field_set:primary.SET_TLM_STATUS.driver)
}

// uint32 circuit = 4;
inline void SET_TLM_STATUS::clear_circuit() {
  circuit_ = 0u;
}
inline uint32_t SET_TLM_STATUS::_internal_circuit() const {
  return circuit_;
}
inline uint32_t SET_TLM_STATUS::circuit() const {
  // @@protoc_insertion_point(field_get:primary.SET_TLM_STATUS.circuit)
  return _internal_circuit();
}
inline void SET_TLM_STATUS::_internal_set_circuit(uint32_t value) {
  
  circuit_ = value;
}
inline void SET_TLM_STATUS::set_circuit(uint32_t value) {
  _internal_set_circuit(value);
  // @@protoc_insertion_point(field_set:primary.SET_TLM_STATUS.circuit)
}

// -------------------------------------------------------------------

// STEER_SYSTEM_STATUS

// uint32 soc_temp = 1;
inline void STEER_SYSTEM_STATUS::clear_soc_temp() {
  soc_temp_ = 0u;
}
inline uint32_t STEER_SYSTEM_STATUS::_internal_soc_temp() const {
  return soc_temp_;
}
inline uint32_t STEER_SYSTEM_STATUS::soc_temp() const {
  // @@protoc_insertion_point(field_get:primary.STEER_SYSTEM_STATUS.soc_temp)
  return _internal_soc_temp();
}
inline void STEER_SYSTEM_STATUS::_internal_set_soc_temp(uint32_t value) {
  
  soc_temp_ = value;
}
inline void STEER_SYSTEM_STATUS::set_soc_temp(uint32_t value) {
  _internal_set_soc_temp(value);
  // @@protoc_insertion_point(field_set:primary.STEER_SYSTEM_STATUS.soc_temp)
}

// -------------------------------------------------------------------

// TLM_STATUS

// .primary.Tlm_Status tlm_status = 1;
inline void TLM_STATUS::clear_tlm_status() {
  tlm_status_ = 0;
}
inline ::primary::Tlm_Status TLM_STATUS::_internal_tlm_status() const {
  return static_cast< ::primary::Tlm_Status >(tlm_status_);
}
inline ::primary::Tlm_Status TLM_STATUS::tlm_status() const {
  // @@protoc_insertion_point(field_get:primary.TLM_STATUS.tlm_status)
  return _internal_tlm_status();
}
inline void TLM_STATUS::_internal_set_tlm_status(::primary::Tlm_Status value) {
  
  tlm_status_ = value;
}
inline void TLM_STATUS::set_tlm_status(::primary::Tlm_Status value) {
  _internal_set_tlm_status(value);
  // @@protoc_insertion_point(field_set:primary.TLM_STATUS.tlm_status)
}

// .primary.Race_Type race_type = 2;
inline void TLM_STATUS::clear_race_type() {
  race_type_ = 0;
}
inline ::primary::Race_Type TLM_STATUS::_internal_race_type() const {
  return static_cast< ::primary::Race_Type >(race_type_);
}
inline ::primary::Race_Type TLM_STATUS::race_type() const {
  // @@protoc_insertion_point(field_get:primary.TLM_STATUS.race_type)
  return _internal_race_type();
}
inline void TLM_STATUS::_internal_set_race_type(::primary::Race_Type value) {
  
  race_type_ = value;
}
inline void TLM_STATUS::set_race_type(::primary::Race_Type value) {
  _internal_set_race_type(value);
  // @@protoc_insertion_point(field_set:primary.TLM_STATUS.race_type)
}

// uint32 driver = 3;
inline void TLM_STATUS::clear_driver() {
  driver_ = 0u;
}
inline uint32_t TLM_STATUS::_internal_driver() const {
  return driver_;
}
inline uint32_t TLM_STATUS::driver() const {
  // @@protoc_insertion_point(field_get:primary.TLM_STATUS.driver)
  return _internal_driver();
}
inline void TLM_STATUS::_internal_set_driver(uint32_t value) {
  
  driver_ = value;
}
inline void TLM_STATUS::set_driver(uint32_t value) {
  _internal_set_driver(value);
  // @@protoc_insertion_point(field_set:primary.TLM_STATUS.driver)
}

// uint32 circuit = 4;
inline void TLM_STATUS::clear_circuit() {
  circuit_ = 0u;
}
inline uint32_t TLM_STATUS::_internal_circuit() const {
  return circuit_;
}
inline uint32_t TLM_STATUS::circuit() const {
  // @@protoc_insertion_point(field_get:primary.TLM_STATUS.circuit)
  return _internal_circuit();
}
inline void TLM_STATUS::_internal_set_circuit(uint32_t value) {
  
  circuit_ = value;
}
inline void TLM_STATUS::set_circuit(uint32_t value) {
  _internal_set_circuit(value);
  // @@protoc_insertion_point(field_set:primary.TLM_STATUS.circuit)
}

// -------------------------------------------------------------------

// CAR_STATUS

// .primary.Inverter_Status inverter_l = 1;
inline void CAR_STATUS::clear_inverter_l() {
  inverter_l_ = 0;
}
inline ::primary::Inverter_Status CAR_STATUS::_internal_inverter_l() const {
  return static_cast< ::primary::Inverter_Status >(inverter_l_);
}
inline ::primary::Inverter_Status CAR_STATUS::inverter_l() const {
  // @@protoc_insertion_point(field_get:primary.CAR_STATUS.inverter_l)
  return _internal_inverter_l();
}
inline void CAR_STATUS::_internal_set_inverter_l(::primary::Inverter_Status value) {
  
  inverter_l_ = value;
}
inline void CAR_STATUS::set_inverter_l(::primary::Inverter_Status value) {
  _internal_set_inverter_l(value);
  // @@protoc_insertion_point(field_set:primary.CAR_STATUS.inverter_l)
}

// .primary.Inverter_Status inverter_r = 2;
inline void CAR_STATUS::clear_inverter_r() {
  inverter_r_ = 0;
}
inline ::primary::Inverter_Status CAR_STATUS::_internal_inverter_r() const {
  return static_cast< ::primary::Inverter_Status >(inverter_r_);
}
inline ::primary::Inverter_Status CAR_STATUS::inverter_r() const {
  // @@protoc_insertion_point(field_get:primary.CAR_STATUS.inverter_r)
  return _internal_inverter_r();
}
inline void CAR_STATUS::_internal_set_inverter_r(::primary::Inverter_Status value) {
  
  inverter_r_ = value;
}
inline void CAR_STATUS::set_inverter_r(::primary::Inverter_Status value) {
  _internal_set_inverter_r(value);
  // @@protoc_insertion_point(field_set:primary.CAR_STATUS.inverter_r)
}

// .primary.Car_Status car_status = 3;
inline void CAR_STATUS::clear_car_status() {
  car_status_ = 0;
}
inline ::primary::Car_Status CAR_STATUS::_internal_car_status() const {
  return static_cast< ::primary::Car_Status >(car_status_);
}
inline ::primary::Car_Status CAR_STATUS::car_status() const {
  // @@protoc_insertion_point(field_get:primary.CAR_STATUS.car_status)
  return _internal_car_status();
}
inline void CAR_STATUS::_internal_set_car_status(::primary::Car_Status value) {
  
  car_status_ = value;
}
inline void CAR_STATUS::set_car_status(::primary::Car_Status value) {
  _internal_set_car_status(value);
  // @@protoc_insertion_point(field_set:primary.CAR_STATUS.car_status)
}

// -------------------------------------------------------------------

// SPEED

// uint32 encoder_r = 1;
inline void SPEED::clear_encoder_r() {
  encoder_r_ = 0u;
}
inline uint32_t SPEED::_internal_encoder_r() const {
  return encoder_r_;
}
inline uint32_t SPEED::encoder_r() const {
  // @@protoc_insertion_point(field_get:primary.SPEED.encoder_r)
  return _internal_encoder_r();
}
inline void SPEED::_internal_set_encoder_r(uint32_t value) {
  
  encoder_r_ = value;
}
inline void SPEED::set_encoder_r(uint32_t value) {
  _internal_set_encoder_r(value);
  // @@protoc_insertion_point(field_set:primary.SPEED.encoder_r)
}

// uint32 encoder_l = 2;
inline void SPEED::clear_encoder_l() {
  encoder_l_ = 0u;
}
inline uint32_t SPEED::_internal_encoder_l() const {
  return encoder_l_;
}
inline uint32_t SPEED::encoder_l() const {
  // @@protoc_insertion_point(field_get:primary.SPEED.encoder_l)
  return _internal_encoder_l();
}
inline void SPEED::_internal_set_encoder_l(uint32_t value) {
  
  encoder_l_ = value;
}
inline void SPEED::set_encoder_l(uint32_t value) {
  _internal_set_encoder_l(value);
  // @@protoc_insertion_point(field_set:primary.SPEED.encoder_l)
}

// uint32 inverter_r = 3;
inline void SPEED::clear_inverter_r() {
  inverter_r_ = 0u;
}
inline uint32_t SPEED::_internal_inverter_r() const {
  return inverter_r_;
}
inline uint32_t SPEED::inverter_r() const {
  // @@protoc_insertion_point(field_get:primary.SPEED.inverter_r)
  return _internal_inverter_r();
}
inline void SPEED::_internal_set_inverter_r(uint32_t value) {
  
  inverter_r_ = value;
}
inline void SPEED::set_inverter_r(uint32_t value) {
  _internal_set_inverter_r(value);
  // @@protoc_insertion_point(field_set:primary.SPEED.inverter_r)
}

// uint32 inverter_l = 4;
inline void SPEED::clear_inverter_l() {
  inverter_l_ = 0u;
}
inline uint32_t SPEED::_internal_inverter_l() const {
  return inverter_l_;
}
inline uint32_t SPEED::inverter_l() const {
  // @@protoc_insertion_point(field_get:primary.SPEED.inverter_l)
  return _internal_inverter_l();
}
inline void SPEED::_internal_set_inverter_l(uint32_t value) {
  
  inverter_l_ = value;
}
inline void SPEED::set_inverter_l(uint32_t value) {
  _internal_set_inverter_l(value);
  // @@protoc_insertion_point(field_set:primary.SPEED.inverter_l)
}

// -------------------------------------------------------------------

// HV_VOLTAGE

// uint32 pack_voltage = 1;
inline void HV_VOLTAGE::clear_pack_voltage() {
  pack_voltage_ = 0u;
}
inline uint32_t HV_VOLTAGE::_internal_pack_voltage() const {
  return pack_voltage_;
}
inline uint32_t HV_VOLTAGE::pack_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HV_VOLTAGE.pack_voltage)
  return _internal_pack_voltage();
}
inline void HV_VOLTAGE::_internal_set_pack_voltage(uint32_t value) {
  
  pack_voltage_ = value;
}
inline void HV_VOLTAGE::set_pack_voltage(uint32_t value) {
  _internal_set_pack_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HV_VOLTAGE.pack_voltage)
}

// uint32 bus_voltage = 2;
inline void HV_VOLTAGE::clear_bus_voltage() {
  bus_voltage_ = 0u;
}
inline uint32_t HV_VOLTAGE::_internal_bus_voltage() const {
  return bus_voltage_;
}
inline uint32_t HV_VOLTAGE::bus_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HV_VOLTAGE.bus_voltage)
  return _internal_bus_voltage();
}
inline void HV_VOLTAGE::_internal_set_bus_voltage(uint32_t value) {
  
  bus_voltage_ = value;
}
inline void HV_VOLTAGE::set_bus_voltage(uint32_t value) {
  _internal_set_bus_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HV_VOLTAGE.bus_voltage)
}

// uint32 max_cell_voltage = 3;
inline void HV_VOLTAGE::clear_max_cell_voltage() {
  max_cell_voltage_ = 0u;
}
inline uint32_t HV_VOLTAGE::_internal_max_cell_voltage() const {
  return max_cell_voltage_;
}
inline uint32_t HV_VOLTAGE::max_cell_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HV_VOLTAGE.max_cell_voltage)
  return _internal_max_cell_voltage();
}
inline void HV_VOLTAGE::_internal_set_max_cell_voltage(uint32_t value) {
  
  max_cell_voltage_ = value;
}
inline void HV_VOLTAGE::set_max_cell_voltage(uint32_t value) {
  _internal_set_max_cell_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HV_VOLTAGE.max_cell_voltage)
}

// uint32 min_cell_voltage = 4;
inline void HV_VOLTAGE::clear_min_cell_voltage() {
  min_cell_voltage_ = 0u;
}
inline uint32_t HV_VOLTAGE::_internal_min_cell_voltage() const {
  return min_cell_voltage_;
}
inline uint32_t HV_VOLTAGE::min_cell_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HV_VOLTAGE.min_cell_voltage)
  return _internal_min_cell_voltage();
}
inline void HV_VOLTAGE::_internal_set_min_cell_voltage(uint32_t value) {
  
  min_cell_voltage_ = value;
}
inline void HV_VOLTAGE::set_min_cell_voltage(uint32_t value) {
  _internal_set_min_cell_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HV_VOLTAGE.min_cell_voltage)
}

// -------------------------------------------------------------------

// HV_CURRENT

// uint32 current = 1;
inline void HV_CURRENT::clear_current() {
  current_ = 0u;
}
inline uint32_t HV_CURRENT::_internal_current() const {
  return current_;
}
inline uint32_t HV_CURRENT::current() const {
  // @@protoc_insertion_point(field_get:primary.HV_CURRENT.current)
  return _internal_current();
}
inline void HV_CURRENT::_internal_set_current(uint32_t value) {
  
  current_ = value;
}
inline void HV_CURRENT::set_current(uint32_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:primary.HV_CURRENT.current)
}

// int32 power = 2;
inline void HV_CURRENT::clear_power() {
  power_ = 0;
}
inline int32_t HV_CURRENT::_internal_power() const {
  return power_;
}
inline int32_t HV_CURRENT::power() const {
  // @@protoc_insertion_point(field_get:primary.HV_CURRENT.power)
  return _internal_power();
}
inline void HV_CURRENT::_internal_set_power(int32_t value) {
  
  power_ = value;
}
inline void HV_CURRENT::set_power(int32_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:primary.HV_CURRENT.power)
}

// -------------------------------------------------------------------

// HV_TEMP

// uint32 average_temp = 1;
inline void HV_TEMP::clear_average_temp() {
  average_temp_ = 0u;
}
inline uint32_t HV_TEMP::_internal_average_temp() const {
  return average_temp_;
}
inline uint32_t HV_TEMP::average_temp() const {
  // @@protoc_insertion_point(field_get:primary.HV_TEMP.average_temp)
  return _internal_average_temp();
}
inline void HV_TEMP::_internal_set_average_temp(uint32_t value) {
  
  average_temp_ = value;
}
inline void HV_TEMP::set_average_temp(uint32_t value) {
  _internal_set_average_temp(value);
  // @@protoc_insertion_point(field_set:primary.HV_TEMP.average_temp)
}

// uint32 max_temp = 2;
inline void HV_TEMP::clear_max_temp() {
  max_temp_ = 0u;
}
inline uint32_t HV_TEMP::_internal_max_temp() const {
  return max_temp_;
}
inline uint32_t HV_TEMP::max_temp() const {
  // @@protoc_insertion_point(field_get:primary.HV_TEMP.max_temp)
  return _internal_max_temp();
}
inline void HV_TEMP::_internal_set_max_temp(uint32_t value) {
  
  max_temp_ = value;
}
inline void HV_TEMP::set_max_temp(uint32_t value) {
  _internal_set_max_temp(value);
  // @@protoc_insertion_point(field_set:primary.HV_TEMP.max_temp)
}

// uint32 min_temp = 3;
inline void HV_TEMP::clear_min_temp() {
  min_temp_ = 0u;
}
inline uint32_t HV_TEMP::_internal_min_temp() const {
  return min_temp_;
}
inline uint32_t HV_TEMP::min_temp() const {
  // @@protoc_insertion_point(field_get:primary.HV_TEMP.min_temp)
  return _internal_min_temp();
}
inline void HV_TEMP::_internal_set_min_temp(uint32_t value) {
  
  min_temp_ = value;
}
inline void HV_TEMP::set_min_temp(uint32_t value) {
  _internal_set_min_temp(value);
  // @@protoc_insertion_point(field_set:primary.HV_TEMP.min_temp)
}

// -------------------------------------------------------------------

// HV_ERRORS

// uint32 warnings = 1;
inline void HV_ERRORS::clear_warnings() {
  warnings_ = 0u;
}
inline uint32_t HV_ERRORS::_internal_warnings() const {
  return warnings_;
}
inline uint32_t HV_ERRORS::warnings() const {
  // @@protoc_insertion_point(field_get:primary.HV_ERRORS.warnings)
  return _internal_warnings();
}
inline void HV_ERRORS::_internal_set_warnings(uint32_t value) {
  
  warnings_ = value;
}
inline void HV_ERRORS::set_warnings(uint32_t value) {
  _internal_set_warnings(value);
  // @@protoc_insertion_point(field_set:primary.HV_ERRORS.warnings)
}

// uint32 errors = 2;
inline void HV_ERRORS::clear_errors() {
  errors_ = 0u;
}
inline uint32_t HV_ERRORS::_internal_errors() const {
  return errors_;
}
inline uint32_t HV_ERRORS::errors() const {
  // @@protoc_insertion_point(field_get:primary.HV_ERRORS.errors)
  return _internal_errors();
}
inline void HV_ERRORS::_internal_set_errors(uint32_t value) {
  
  errors_ = value;
}
inline void HV_ERRORS::set_errors(uint32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:primary.HV_ERRORS.errors)
}

// -------------------------------------------------------------------

// TS_STATUS

// .primary.Ts_Status ts_status = 1;
inline void TS_STATUS::clear_ts_status() {
  ts_status_ = 0;
}
inline ::primary::Ts_Status TS_STATUS::_internal_ts_status() const {
  return static_cast< ::primary::Ts_Status >(ts_status_);
}
inline ::primary::Ts_Status TS_STATUS::ts_status() const {
  // @@protoc_insertion_point(field_get:primary.TS_STATUS.ts_status)
  return _internal_ts_status();
}
inline void TS_STATUS::_internal_set_ts_status(::primary::Ts_Status value) {
  
  ts_status_ = value;
}
inline void TS_STATUS::set_ts_status(::primary::Ts_Status value) {
  _internal_set_ts_status(value);
  // @@protoc_insertion_point(field_set:primary.TS_STATUS.ts_status)
}

// -------------------------------------------------------------------

// SET_TS_STATUS

// .primary.Ts_Status_Set ts_status_set = 1;
inline void SET_TS_STATUS::clear_ts_status_set() {
  ts_status_set_ = 0;
}
inline ::primary::Ts_Status_Set SET_TS_STATUS::_internal_ts_status_set() const {
  return static_cast< ::primary::Ts_Status_Set >(ts_status_set_);
}
inline ::primary::Ts_Status_Set SET_TS_STATUS::ts_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SET_TS_STATUS.ts_status_set)
  return _internal_ts_status_set();
}
inline void SET_TS_STATUS::_internal_set_ts_status_set(::primary::Ts_Status_Set value) {
  
  ts_status_set_ = value;
}
inline void SET_TS_STATUS::set_ts_status_set(::primary::Ts_Status_Set value) {
  _internal_set_ts_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SET_TS_STATUS.ts_status_set)
}

// -------------------------------------------------------------------

// SET_CELL_BALANCING_STATUS

// .primary.Set_Balancing_Status set_balancing_status = 1;
inline void SET_CELL_BALANCING_STATUS::clear_set_balancing_status() {
  set_balancing_status_ = 0;
}
inline ::primary::Set_Balancing_Status SET_CELL_BALANCING_STATUS::_internal_set_balancing_status() const {
  return static_cast< ::primary::Set_Balancing_Status >(set_balancing_status_);
}
inline ::primary::Set_Balancing_Status SET_CELL_BALANCING_STATUS::set_balancing_status() const {
  // @@protoc_insertion_point(field_get:primary.SET_CELL_BALANCING_STATUS.set_balancing_status)
  return _internal_set_balancing_status();
}
inline void SET_CELL_BALANCING_STATUS::_internal_set_set_balancing_status(::primary::Set_Balancing_Status value) {
  
  set_balancing_status_ = value;
}
inline void SET_CELL_BALANCING_STATUS::set_set_balancing_status(::primary::Set_Balancing_Status value) {
  _internal_set_set_balancing_status(value);
  // @@protoc_insertion_point(field_set:primary.SET_CELL_BALANCING_STATUS.set_balancing_status)
}

// -------------------------------------------------------------------

// HANDCART_STATUS

// bool connected = 1;
inline void HANDCART_STATUS::clear_connected() {
  connected_ = false;
}
inline bool HANDCART_STATUS::_internal_connected() const {
  return connected_;
}
inline bool HANDCART_STATUS::connected() const {
  // @@protoc_insertion_point(field_get:primary.HANDCART_STATUS.connected)
  return _internal_connected();
}
inline void HANDCART_STATUS::_internal_set_connected(bool value) {
  
  connected_ = value;
}
inline void HANDCART_STATUS::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:primary.HANDCART_STATUS.connected)
}

// -------------------------------------------------------------------

// STEER_STATUS

// .primary.Traction_Control traction_control = 1;
inline void STEER_STATUS::clear_traction_control() {
  traction_control_ = 0;
}
inline ::primary::Traction_Control STEER_STATUS::_internal_traction_control() const {
  return static_cast< ::primary::Traction_Control >(traction_control_);
}
inline ::primary::Traction_Control STEER_STATUS::traction_control() const {
  // @@protoc_insertion_point(field_get:primary.STEER_STATUS.traction_control)
  return _internal_traction_control();
}
inline void STEER_STATUS::_internal_set_traction_control(::primary::Traction_Control value) {
  
  traction_control_ = value;
}
inline void STEER_STATUS::set_traction_control(::primary::Traction_Control value) {
  _internal_set_traction_control(value);
  // @@protoc_insertion_point(field_set:primary.STEER_STATUS.traction_control)
}

// .primary.Map map = 2;
inline void STEER_STATUS::clear_map() {
  map_ = 0;
}
inline ::primary::Map STEER_STATUS::_internal_map() const {
  return static_cast< ::primary::Map >(map_);
}
inline ::primary::Map STEER_STATUS::map() const {
  // @@protoc_insertion_point(field_get:primary.STEER_STATUS.map)
  return _internal_map();
}
inline void STEER_STATUS::_internal_set_map(::primary::Map value) {
  
  map_ = value;
}
inline void STEER_STATUS::set_map(::primary::Map value) {
  _internal_set_map(value);
  // @@protoc_insertion_point(field_set:primary.STEER_STATUS.map)
}

// -------------------------------------------------------------------

// SET_CAR_STATUS

// .primary.Car_Status_Set car_status_set = 1;
inline void SET_CAR_STATUS::clear_car_status_set() {
  car_status_set_ = 0;
}
inline ::primary::Car_Status_Set SET_CAR_STATUS::_internal_car_status_set() const {
  return static_cast< ::primary::Car_Status_Set >(car_status_set_);
}
inline ::primary::Car_Status_Set SET_CAR_STATUS::car_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SET_CAR_STATUS.car_status_set)
  return _internal_car_status_set();
}
inline void SET_CAR_STATUS::_internal_set_car_status_set(::primary::Car_Status_Set value) {
  
  car_status_set_ = value;
}
inline void SET_CAR_STATUS::set_car_status_set(::primary::Car_Status_Set value) {
  _internal_set_car_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SET_CAR_STATUS.car_status_set)
}

// -------------------------------------------------------------------

// SET_PEDALS_RANGE

// .primary.Bound bound = 1;
inline void SET_PEDALS_RANGE::clear_bound() {
  bound_ = 0;
}
inline ::primary::Bound SET_PEDALS_RANGE::_internal_bound() const {
  return static_cast< ::primary::Bound >(bound_);
}
inline ::primary::Bound SET_PEDALS_RANGE::bound() const {
  // @@protoc_insertion_point(field_get:primary.SET_PEDALS_RANGE.bound)
  return _internal_bound();
}
inline void SET_PEDALS_RANGE::_internal_set_bound(::primary::Bound value) {
  
  bound_ = value;
}
inline void SET_PEDALS_RANGE::set_bound(::primary::Bound value) {
  _internal_set_bound(value);
  // @@protoc_insertion_point(field_set:primary.SET_PEDALS_RANGE.bound)
}

// .primary.Pedal pedal = 2;
inline void SET_PEDALS_RANGE::clear_pedal() {
  pedal_ = 0;
}
inline ::primary::Pedal SET_PEDALS_RANGE::_internal_pedal() const {
  return static_cast< ::primary::Pedal >(pedal_);
}
inline ::primary::Pedal SET_PEDALS_RANGE::pedal() const {
  // @@protoc_insertion_point(field_get:primary.SET_PEDALS_RANGE.pedal)
  return _internal_pedal();
}
inline void SET_PEDALS_RANGE::_internal_set_pedal(::primary::Pedal value) {
  
  pedal_ = value;
}
inline void SET_PEDALS_RANGE::set_pedal(::primary::Pedal value) {
  _internal_set_pedal(value);
  // @@protoc_insertion_point(field_set:primary.SET_PEDALS_RANGE.pedal)
}

// -------------------------------------------------------------------

// LV_CURRENT

// uint32 current = 1;
inline void LV_CURRENT::clear_current() {
  current_ = 0u;
}
inline uint32_t LV_CURRENT::_internal_current() const {
  return current_;
}
inline uint32_t LV_CURRENT::current() const {
  // @@protoc_insertion_point(field_get:primary.LV_CURRENT.current)
  return _internal_current();
}
inline void LV_CURRENT::_internal_set_current(uint32_t value) {
  
  current_ = value;
}
inline void LV_CURRENT::set_current(uint32_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:primary.LV_CURRENT.current)
}

// -------------------------------------------------------------------

// LV_VOLTAGE

// uint32 total_voltage = 1;
inline void LV_VOLTAGE::clear_total_voltage() {
  total_voltage_ = 0u;
}
inline uint32_t LV_VOLTAGE::_internal_total_voltage() const {
  return total_voltage_;
}
inline uint32_t LV_VOLTAGE::total_voltage() const {
  // @@protoc_insertion_point(field_get:primary.LV_VOLTAGE.total_voltage)
  return _internal_total_voltage();
}
inline void LV_VOLTAGE::_internal_set_total_voltage(uint32_t value) {
  
  total_voltage_ = value;
}
inline void LV_VOLTAGE::set_total_voltage(uint32_t value) {
  _internal_set_total_voltage(value);
  // @@protoc_insertion_point(field_set:primary.LV_VOLTAGE.total_voltage)
}

// uint32 voltage_1 = 2;
inline void LV_VOLTAGE::clear_voltage_1() {
  voltage_1_ = 0u;
}
inline uint32_t LV_VOLTAGE::_internal_voltage_1() const {
  return voltage_1_;
}
inline uint32_t LV_VOLTAGE::voltage_1() const {
  // @@protoc_insertion_point(field_get:primary.LV_VOLTAGE.voltage_1)
  return _internal_voltage_1();
}
inline void LV_VOLTAGE::_internal_set_voltage_1(uint32_t value) {
  
  voltage_1_ = value;
}
inline void LV_VOLTAGE::set_voltage_1(uint32_t value) {
  _internal_set_voltage_1(value);
  // @@protoc_insertion_point(field_set:primary.LV_VOLTAGE.voltage_1)
}

// uint32 voltage_2 = 3;
inline void LV_VOLTAGE::clear_voltage_2() {
  voltage_2_ = 0u;
}
inline uint32_t LV_VOLTAGE::_internal_voltage_2() const {
  return voltage_2_;
}
inline uint32_t LV_VOLTAGE::voltage_2() const {
  // @@protoc_insertion_point(field_get:primary.LV_VOLTAGE.voltage_2)
  return _internal_voltage_2();
}
inline void LV_VOLTAGE::_internal_set_voltage_2(uint32_t value) {
  
  voltage_2_ = value;
}
inline void LV_VOLTAGE::set_voltage_2(uint32_t value) {
  _internal_set_voltage_2(value);
  // @@protoc_insertion_point(field_set:primary.LV_VOLTAGE.voltage_2)
}

// uint32 voltage_3 = 4;
inline void LV_VOLTAGE::clear_voltage_3() {
  voltage_3_ = 0u;
}
inline uint32_t LV_VOLTAGE::_internal_voltage_3() const {
  return voltage_3_;
}
inline uint32_t LV_VOLTAGE::voltage_3() const {
  // @@protoc_insertion_point(field_get:primary.LV_VOLTAGE.voltage_3)
  return _internal_voltage_3();
}
inline void LV_VOLTAGE::_internal_set_voltage_3(uint32_t value) {
  
  voltage_3_ = value;
}
inline void LV_VOLTAGE::set_voltage_3(uint32_t value) {
  _internal_set_voltage_3(value);
  // @@protoc_insertion_point(field_set:primary.LV_VOLTAGE.voltage_3)
}

// uint32 voltage_4 = 5;
inline void LV_VOLTAGE::clear_voltage_4() {
  voltage_4_ = 0u;
}
inline uint32_t LV_VOLTAGE::_internal_voltage_4() const {
  return voltage_4_;
}
inline uint32_t LV_VOLTAGE::voltage_4() const {
  // @@protoc_insertion_point(field_get:primary.LV_VOLTAGE.voltage_4)
  return _internal_voltage_4();
}
inline void LV_VOLTAGE::_internal_set_voltage_4(uint32_t value) {
  
  voltage_4_ = value;
}
inline void LV_VOLTAGE::set_voltage_4(uint32_t value) {
  _internal_set_voltage_4(value);
  // @@protoc_insertion_point(field_set:primary.LV_VOLTAGE.voltage_4)
}

// -------------------------------------------------------------------

// LV_TEMPERATURE

// uint32 bp_temperature = 1;
inline void LV_TEMPERATURE::clear_bp_temperature() {
  bp_temperature_ = 0u;
}
inline uint32_t LV_TEMPERATURE::_internal_bp_temperature() const {
  return bp_temperature_;
}
inline uint32_t LV_TEMPERATURE::bp_temperature() const {
  // @@protoc_insertion_point(field_get:primary.LV_TEMPERATURE.bp_temperature)
  return _internal_bp_temperature();
}
inline void LV_TEMPERATURE::_internal_set_bp_temperature(uint32_t value) {
  
  bp_temperature_ = value;
}
inline void LV_TEMPERATURE::set_bp_temperature(uint32_t value) {
  _internal_set_bp_temperature(value);
  // @@protoc_insertion_point(field_set:primary.LV_TEMPERATURE.bp_temperature)
}

// uint32 dcdc_temperature = 2;
inline void LV_TEMPERATURE::clear_dcdc_temperature() {
  dcdc_temperature_ = 0u;
}
inline uint32_t LV_TEMPERATURE::_internal_dcdc_temperature() const {
  return dcdc_temperature_;
}
inline uint32_t LV_TEMPERATURE::dcdc_temperature() const {
  // @@protoc_insertion_point(field_get:primary.LV_TEMPERATURE.dcdc_temperature)
  return _internal_dcdc_temperature();
}
inline void LV_TEMPERATURE::_internal_set_dcdc_temperature(uint32_t value) {
  
  dcdc_temperature_ = value;
}
inline void LV_TEMPERATURE::set_dcdc_temperature(uint32_t value) {
  _internal_set_dcdc_temperature(value);
  // @@protoc_insertion_point(field_set:primary.LV_TEMPERATURE.dcdc_temperature)
}

// -------------------------------------------------------------------

// COOLING_STATUS

// uint32 hv_fan_speed = 1;
inline void COOLING_STATUS::clear_hv_fan_speed() {
  hv_fan_speed_ = 0u;
}
inline uint32_t COOLING_STATUS::_internal_hv_fan_speed() const {
  return hv_fan_speed_;
}
inline uint32_t COOLING_STATUS::hv_fan_speed() const {
  // @@protoc_insertion_point(field_get:primary.COOLING_STATUS.hv_fan_speed)
  return _internal_hv_fan_speed();
}
inline void COOLING_STATUS::_internal_set_hv_fan_speed(uint32_t value) {
  
  hv_fan_speed_ = value;
}
inline void COOLING_STATUS::set_hv_fan_speed(uint32_t value) {
  _internal_set_hv_fan_speed(value);
  // @@protoc_insertion_point(field_set:primary.COOLING_STATUS.hv_fan_speed)
}

// uint32 lv_fan_speed = 2;
inline void COOLING_STATUS::clear_lv_fan_speed() {
  lv_fan_speed_ = 0u;
}
inline uint32_t COOLING_STATUS::_internal_lv_fan_speed() const {
  return lv_fan_speed_;
}
inline uint32_t COOLING_STATUS::lv_fan_speed() const {
  // @@protoc_insertion_point(field_get:primary.COOLING_STATUS.lv_fan_speed)
  return _internal_lv_fan_speed();
}
inline void COOLING_STATUS::_internal_set_lv_fan_speed(uint32_t value) {
  
  lv_fan_speed_ = value;
}
inline void COOLING_STATUS::set_lv_fan_speed(uint32_t value) {
  _internal_set_lv_fan_speed(value);
  // @@protoc_insertion_point(field_set:primary.COOLING_STATUS.lv_fan_speed)
}

// uint32 pump_speed = 3;
inline void COOLING_STATUS::clear_pump_speed() {
  pump_speed_ = 0u;
}
inline uint32_t COOLING_STATUS::_internal_pump_speed() const {
  return pump_speed_;
}
inline uint32_t COOLING_STATUS::pump_speed() const {
  // @@protoc_insertion_point(field_get:primary.COOLING_STATUS.pump_speed)
  return _internal_pump_speed();
}
inline void COOLING_STATUS::_internal_set_pump_speed(uint32_t value) {
  
  pump_speed_ = value;
}
inline void COOLING_STATUS::set_pump_speed(uint32_t value) {
  _internal_set_pump_speed(value);
  // @@protoc_insertion_point(field_set:primary.COOLING_STATUS.pump_speed)
}

// -------------------------------------------------------------------

// HV_CELLS_VOLTAGE

// uint32 cell_index = 1;
inline void HV_CELLS_VOLTAGE::clear_cell_index() {
  cell_index_ = 0u;
}
inline uint32_t HV_CELLS_VOLTAGE::_internal_cell_index() const {
  return cell_index_;
}
inline uint32_t HV_CELLS_VOLTAGE::cell_index() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_VOLTAGE.cell_index)
  return _internal_cell_index();
}
inline void HV_CELLS_VOLTAGE::_internal_set_cell_index(uint32_t value) {
  
  cell_index_ = value;
}
inline void HV_CELLS_VOLTAGE::set_cell_index(uint32_t value) {
  _internal_set_cell_index(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_VOLTAGE.cell_index)
}

// uint32 voltage_0 = 2;
inline void HV_CELLS_VOLTAGE::clear_voltage_0() {
  voltage_0_ = 0u;
}
inline uint32_t HV_CELLS_VOLTAGE::_internal_voltage_0() const {
  return voltage_0_;
}
inline uint32_t HV_CELLS_VOLTAGE::voltage_0() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_VOLTAGE.voltage_0)
  return _internal_voltage_0();
}
inline void HV_CELLS_VOLTAGE::_internal_set_voltage_0(uint32_t value) {
  
  voltage_0_ = value;
}
inline void HV_CELLS_VOLTAGE::set_voltage_0(uint32_t value) {
  _internal_set_voltage_0(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_VOLTAGE.voltage_0)
}

// uint32 voltage_1 = 3;
inline void HV_CELLS_VOLTAGE::clear_voltage_1() {
  voltage_1_ = 0u;
}
inline uint32_t HV_CELLS_VOLTAGE::_internal_voltage_1() const {
  return voltage_1_;
}
inline uint32_t HV_CELLS_VOLTAGE::voltage_1() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_VOLTAGE.voltage_1)
  return _internal_voltage_1();
}
inline void HV_CELLS_VOLTAGE::_internal_set_voltage_1(uint32_t value) {
  
  voltage_1_ = value;
}
inline void HV_CELLS_VOLTAGE::set_voltage_1(uint32_t value) {
  _internal_set_voltage_1(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_VOLTAGE.voltage_1)
}

// uint32 voltage_2 = 4;
inline void HV_CELLS_VOLTAGE::clear_voltage_2() {
  voltage_2_ = 0u;
}
inline uint32_t HV_CELLS_VOLTAGE::_internal_voltage_2() const {
  return voltage_2_;
}
inline uint32_t HV_CELLS_VOLTAGE::voltage_2() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_VOLTAGE.voltage_2)
  return _internal_voltage_2();
}
inline void HV_CELLS_VOLTAGE::_internal_set_voltage_2(uint32_t value) {
  
  voltage_2_ = value;
}
inline void HV_CELLS_VOLTAGE::set_voltage_2(uint32_t value) {
  _internal_set_voltage_2(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_VOLTAGE.voltage_2)
}

// -------------------------------------------------------------------

// HV_CELLS_TEMP

// uint32 cell_index = 1;
inline void HV_CELLS_TEMP::clear_cell_index() {
  cell_index_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_cell_index() const {
  return cell_index_;
}
inline uint32_t HV_CELLS_TEMP::cell_index() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.cell_index)
  return _internal_cell_index();
}
inline void HV_CELLS_TEMP::_internal_set_cell_index(uint32_t value) {
  
  cell_index_ = value;
}
inline void HV_CELLS_TEMP::set_cell_index(uint32_t value) {
  _internal_set_cell_index(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.cell_index)
}

// uint32 temp_0 = 2;
inline void HV_CELLS_TEMP::clear_temp_0() {
  temp_0_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_0() const {
  return temp_0_;
}
inline uint32_t HV_CELLS_TEMP::temp_0() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_0)
  return _internal_temp_0();
}
inline void HV_CELLS_TEMP::_internal_set_temp_0(uint32_t value) {
  
  temp_0_ = value;
}
inline void HV_CELLS_TEMP::set_temp_0(uint32_t value) {
  _internal_set_temp_0(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_0)
}

// uint32 temp_1 = 3;
inline void HV_CELLS_TEMP::clear_temp_1() {
  temp_1_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_1() const {
  return temp_1_;
}
inline uint32_t HV_CELLS_TEMP::temp_1() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_1)
  return _internal_temp_1();
}
inline void HV_CELLS_TEMP::_internal_set_temp_1(uint32_t value) {
  
  temp_1_ = value;
}
inline void HV_CELLS_TEMP::set_temp_1(uint32_t value) {
  _internal_set_temp_1(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_1)
}

// uint32 temp_2 = 4;
inline void HV_CELLS_TEMP::clear_temp_2() {
  temp_2_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_2() const {
  return temp_2_;
}
inline uint32_t HV_CELLS_TEMP::temp_2() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_2)
  return _internal_temp_2();
}
inline void HV_CELLS_TEMP::_internal_set_temp_2(uint32_t value) {
  
  temp_2_ = value;
}
inline void HV_CELLS_TEMP::set_temp_2(uint32_t value) {
  _internal_set_temp_2(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_2)
}

// uint32 temp_3 = 5;
inline void HV_CELLS_TEMP::clear_temp_3() {
  temp_3_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_3() const {
  return temp_3_;
}
inline uint32_t HV_CELLS_TEMP::temp_3() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_3)
  return _internal_temp_3();
}
inline void HV_CELLS_TEMP::_internal_set_temp_3(uint32_t value) {
  
  temp_3_ = value;
}
inline void HV_CELLS_TEMP::set_temp_3(uint32_t value) {
  _internal_set_temp_3(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_3)
}

// uint32 temp_4 = 6;
inline void HV_CELLS_TEMP::clear_temp_4() {
  temp_4_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_4() const {
  return temp_4_;
}
inline uint32_t HV_CELLS_TEMP::temp_4() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_4)
  return _internal_temp_4();
}
inline void HV_CELLS_TEMP::_internal_set_temp_4(uint32_t value) {
  
  temp_4_ = value;
}
inline void HV_CELLS_TEMP::set_temp_4(uint32_t value) {
  _internal_set_temp_4(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_4)
}

// uint32 temp_5 = 7;
inline void HV_CELLS_TEMP::clear_temp_5() {
  temp_5_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_5() const {
  return temp_5_;
}
inline uint32_t HV_CELLS_TEMP::temp_5() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_5)
  return _internal_temp_5();
}
inline void HV_CELLS_TEMP::_internal_set_temp_5(uint32_t value) {
  
  temp_5_ = value;
}
inline void HV_CELLS_TEMP::set_temp_5(uint32_t value) {
  _internal_set_temp_5(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_5)
}

// uint32 temp_6 = 8;
inline void HV_CELLS_TEMP::clear_temp_6() {
  temp_6_ = 0u;
}
inline uint32_t HV_CELLS_TEMP::_internal_temp_6() const {
  return temp_6_;
}
inline uint32_t HV_CELLS_TEMP::temp_6() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELLS_TEMP.temp_6)
  return _internal_temp_6();
}
inline void HV_CELLS_TEMP::_internal_set_temp_6(uint32_t value) {
  
  temp_6_ = value;
}
inline void HV_CELLS_TEMP::set_temp_6(uint32_t value) {
  _internal_set_temp_6(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELLS_TEMP.temp_6)
}

// -------------------------------------------------------------------

// HV_CELL_BALANCING_STATUS

// .primary.Balancing_Status balancing_status = 1;
inline void HV_CELL_BALANCING_STATUS::clear_balancing_status() {
  balancing_status_ = 0;
}
inline ::primary::Balancing_Status HV_CELL_BALANCING_STATUS::_internal_balancing_status() const {
  return static_cast< ::primary::Balancing_Status >(balancing_status_);
}
inline ::primary::Balancing_Status HV_CELL_BALANCING_STATUS::balancing_status() const {
  // @@protoc_insertion_point(field_get:primary.HV_CELL_BALANCING_STATUS.balancing_status)
  return _internal_balancing_status();
}
inline void HV_CELL_BALANCING_STATUS::_internal_set_balancing_status(::primary::Balancing_Status value) {
  
  balancing_status_ = value;
}
inline void HV_CELL_BALANCING_STATUS::set_balancing_status(::primary::Balancing_Status value) {
  _internal_set_balancing_status(value);
  // @@protoc_insertion_point(field_set:primary.HV_CELL_BALANCING_STATUS.balancing_status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace primary

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::primary::Tlm_Status_Set> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Tlm_Status_Set>() {
  return ::primary::Tlm_Status_Set_descriptor();
}
template <> struct is_proto_enum< ::primary::Race_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Race_Type>() {
  return ::primary::Race_Type_descriptor();
}
template <> struct is_proto_enum< ::primary::Tlm_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Tlm_Status>() {
  return ::primary::Tlm_Status_descriptor();
}
template <> struct is_proto_enum< ::primary::Inverter_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Inverter_Status>() {
  return ::primary::Inverter_Status_descriptor();
}
template <> struct is_proto_enum< ::primary::Car_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Car_Status>() {
  return ::primary::Car_Status_descriptor();
}
template <> struct is_proto_enum< ::primary::Ts_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Ts_Status>() {
  return ::primary::Ts_Status_descriptor();
}
template <> struct is_proto_enum< ::primary::Ts_Status_Set> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Ts_Status_Set>() {
  return ::primary::Ts_Status_Set_descriptor();
}
template <> struct is_proto_enum< ::primary::Set_Balancing_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Set_Balancing_Status>() {
  return ::primary::Set_Balancing_Status_descriptor();
}
template <> struct is_proto_enum< ::primary::Traction_Control> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Traction_Control>() {
  return ::primary::Traction_Control_descriptor();
}
template <> struct is_proto_enum< ::primary::Map> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Map>() {
  return ::primary::Map_descriptor();
}
template <> struct is_proto_enum< ::primary::Car_Status_Set> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Car_Status_Set>() {
  return ::primary::Car_Status_Set_descriptor();
}
template <> struct is_proto_enum< ::primary::Bound> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Bound>() {
  return ::primary::Bound_descriptor();
}
template <> struct is_proto_enum< ::primary::Pedal> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Pedal>() {
  return ::primary::Pedal_descriptor();
}
template <> struct is_proto_enum< ::primary::Balancing_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::Balancing_Status>() {
  return ::primary::Balancing_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_primary_2eproto
