// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: primary.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_primary_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_primary_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_primary_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_primary_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_primary_2eproto;
namespace primary {
class CarStatus;
struct CarStatusDefaultTypeInternal;
extern CarStatusDefaultTypeInternal _CarStatus_default_instance_;
class CoolingStatus;
struct CoolingStatusDefaultTypeInternal;
extern CoolingStatusDefaultTypeInternal _CoolingStatus_default_instance_;
class DasErrors;
struct DasErrorsDefaultTypeInternal;
extern DasErrorsDefaultTypeInternal _DasErrors_default_instance_;
class DasVersion;
struct DasVersionDefaultTypeInternal;
extern DasVersionDefaultTypeInternal _DasVersion_default_instance_;
class HandcartStatus;
struct HandcartStatusDefaultTypeInternal;
extern HandcartStatusDefaultTypeInternal _HandcartStatus_default_instance_;
class HvCellBalancingStatus;
struct HvCellBalancingStatusDefaultTypeInternal;
extern HvCellBalancingStatusDefaultTypeInternal _HvCellBalancingStatus_default_instance_;
class HvCellsTemp;
struct HvCellsTempDefaultTypeInternal;
extern HvCellsTempDefaultTypeInternal _HvCellsTemp_default_instance_;
class HvCellsVoltage;
struct HvCellsVoltageDefaultTypeInternal;
extern HvCellsVoltageDefaultTypeInternal _HvCellsVoltage_default_instance_;
class HvCurrent;
struct HvCurrentDefaultTypeInternal;
extern HvCurrentDefaultTypeInternal _HvCurrent_default_instance_;
class HvErrors;
struct HvErrorsDefaultTypeInternal;
extern HvErrorsDefaultTypeInternal _HvErrors_default_instance_;
class HvTemp;
struct HvTempDefaultTypeInternal;
extern HvTempDefaultTypeInternal _HvTemp_default_instance_;
class HvVersion;
struct HvVersionDefaultTypeInternal;
extern HvVersionDefaultTypeInternal _HvVersion_default_instance_;
class HvVoltage;
struct HvVoltageDefaultTypeInternal;
extern HvVoltageDefaultTypeInternal _HvVoltage_default_instance_;
class InvLSendCmd;
struct InvLSendCmdDefaultTypeInternal;
extern InvLSendCmdDefaultTypeInternal _InvLSendCmd_default_instance_;
class InvLStatus;
struct InvLStatusDefaultTypeInternal;
extern InvLStatusDefaultTypeInternal _InvLStatus_default_instance_;
class LvCurrent;
struct LvCurrentDefaultTypeInternal;
extern LvCurrentDefaultTypeInternal _LvCurrent_default_instance_;
class LvTemperature;
struct LvTemperatureDefaultTypeInternal;
extern LvTemperatureDefaultTypeInternal _LvTemperature_default_instance_;
class LvVersion;
struct LvVersionDefaultTypeInternal;
extern LvVersionDefaultTypeInternal _LvVersion_default_instance_;
class LvVoltage;
struct LvVoltageDefaultTypeInternal;
extern LvVoltageDefaultTypeInternal _LvVoltage_default_instance_;
class Marker;
struct MarkerDefaultTypeInternal;
extern MarkerDefaultTypeInternal _Marker_default_instance_;
class SetCarStatus;
struct SetCarStatusDefaultTypeInternal;
extern SetCarStatusDefaultTypeInternal _SetCarStatus_default_instance_;
class SetCellBalancingStatus;
struct SetCellBalancingStatusDefaultTypeInternal;
extern SetCellBalancingStatusDefaultTypeInternal _SetCellBalancingStatus_default_instance_;
class SetPedalsRange;
struct SetPedalsRangeDefaultTypeInternal;
extern SetPedalsRangeDefaultTypeInternal _SetPedalsRange_default_instance_;
class SetTlmStatus;
struct SetTlmStatusDefaultTypeInternal;
extern SetTlmStatusDefaultTypeInternal _SetTlmStatus_default_instance_;
class SetTsStatus;
struct SetTsStatusDefaultTypeInternal;
extern SetTsStatusDefaultTypeInternal _SetTsStatus_default_instance_;
class Speed;
struct SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class SteerStatus;
struct SteerStatusDefaultTypeInternal;
extern SteerStatusDefaultTypeInternal _SteerStatus_default_instance_;
class SteerSystemStatus;
struct SteerSystemStatusDefaultTypeInternal;
extern SteerSystemStatusDefaultTypeInternal _SteerSystemStatus_default_instance_;
class SteerVersion;
struct SteerVersionDefaultTypeInternal;
extern SteerVersionDefaultTypeInternal _SteerVersion_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class TlmStatus;
struct TlmStatusDefaultTypeInternal;
extern TlmStatusDefaultTypeInternal _TlmStatus_default_instance_;
class TlmVersion;
struct TlmVersionDefaultTypeInternal;
extern TlmVersionDefaultTypeInternal _TlmVersion_default_instance_;
class TsStatus;
struct TsStatusDefaultTypeInternal;
extern TsStatusDefaultTypeInternal _TsStatus_default_instance_;
}  // namespace primary
PROTOBUF_NAMESPACE_OPEN
template<> ::primary::CarStatus* Arena::CreateMaybeMessage<::primary::CarStatus>(Arena*);
template<> ::primary::CoolingStatus* Arena::CreateMaybeMessage<::primary::CoolingStatus>(Arena*);
template<> ::primary::DasErrors* Arena::CreateMaybeMessage<::primary::DasErrors>(Arena*);
template<> ::primary::DasVersion* Arena::CreateMaybeMessage<::primary::DasVersion>(Arena*);
template<> ::primary::HandcartStatus* Arena::CreateMaybeMessage<::primary::HandcartStatus>(Arena*);
template<> ::primary::HvCellBalancingStatus* Arena::CreateMaybeMessage<::primary::HvCellBalancingStatus>(Arena*);
template<> ::primary::HvCellsTemp* Arena::CreateMaybeMessage<::primary::HvCellsTemp>(Arena*);
template<> ::primary::HvCellsVoltage* Arena::CreateMaybeMessage<::primary::HvCellsVoltage>(Arena*);
template<> ::primary::HvCurrent* Arena::CreateMaybeMessage<::primary::HvCurrent>(Arena*);
template<> ::primary::HvErrors* Arena::CreateMaybeMessage<::primary::HvErrors>(Arena*);
template<> ::primary::HvTemp* Arena::CreateMaybeMessage<::primary::HvTemp>(Arena*);
template<> ::primary::HvVersion* Arena::CreateMaybeMessage<::primary::HvVersion>(Arena*);
template<> ::primary::HvVoltage* Arena::CreateMaybeMessage<::primary::HvVoltage>(Arena*);
template<> ::primary::InvLSendCmd* Arena::CreateMaybeMessage<::primary::InvLSendCmd>(Arena*);
template<> ::primary::InvLStatus* Arena::CreateMaybeMessage<::primary::InvLStatus>(Arena*);
template<> ::primary::LvCurrent* Arena::CreateMaybeMessage<::primary::LvCurrent>(Arena*);
template<> ::primary::LvTemperature* Arena::CreateMaybeMessage<::primary::LvTemperature>(Arena*);
template<> ::primary::LvVersion* Arena::CreateMaybeMessage<::primary::LvVersion>(Arena*);
template<> ::primary::LvVoltage* Arena::CreateMaybeMessage<::primary::LvVoltage>(Arena*);
template<> ::primary::Marker* Arena::CreateMaybeMessage<::primary::Marker>(Arena*);
template<> ::primary::SetCarStatus* Arena::CreateMaybeMessage<::primary::SetCarStatus>(Arena*);
template<> ::primary::SetCellBalancingStatus* Arena::CreateMaybeMessage<::primary::SetCellBalancingStatus>(Arena*);
template<> ::primary::SetPedalsRange* Arena::CreateMaybeMessage<::primary::SetPedalsRange>(Arena*);
template<> ::primary::SetTlmStatus* Arena::CreateMaybeMessage<::primary::SetTlmStatus>(Arena*);
template<> ::primary::SetTsStatus* Arena::CreateMaybeMessage<::primary::SetTsStatus>(Arena*);
template<> ::primary::Speed* Arena::CreateMaybeMessage<::primary::Speed>(Arena*);
template<> ::primary::SteerStatus* Arena::CreateMaybeMessage<::primary::SteerStatus>(Arena*);
template<> ::primary::SteerSystemStatus* Arena::CreateMaybeMessage<::primary::SteerSystemStatus>(Arena*);
template<> ::primary::SteerVersion* Arena::CreateMaybeMessage<::primary::SteerVersion>(Arena*);
template<> ::primary::Timestamp* Arena::CreateMaybeMessage<::primary::Timestamp>(Arena*);
template<> ::primary::TlmStatus* Arena::CreateMaybeMessage<::primary::TlmStatus>(Arena*);
template<> ::primary::TlmVersion* Arena::CreateMaybeMessage<::primary::TlmVersion>(Arena*);
template<> ::primary::TsStatus* Arena::CreateMaybeMessage<::primary::TsStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace primary {

enum TlmStatusSetType : int {
  TLM_STATUS_SET_OFF = 0,
  TLM_STATUS_SET_ON = 1,
  TlmStatusSetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TlmStatusSetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TlmStatusSetType_IsValid(int value);
constexpr TlmStatusSetType TlmStatusSetType_MIN = TLM_STATUS_SET_OFF;
constexpr TlmStatusSetType TlmStatusSetType_MAX = TLM_STATUS_SET_ON;
constexpr int TlmStatusSetType_ARRAYSIZE = TlmStatusSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TlmStatusSetType_descriptor();
template<typename T>
inline const std::string& TlmStatusSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TlmStatusSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TlmStatusSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TlmStatusSetType_descriptor(), enum_t_value);
}
inline bool TlmStatusSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TlmStatusSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TlmStatusSetType>(
    TlmStatusSetType_descriptor(), name, value);
}
enum RaceTypeType : int {
  RACE_TYPE_ACCELERATION = 0,
  RACE_TYPE_SKIDPAD = 1,
  RACE_TYPE_AUTOCROSS = 2,
  RACE_TYPE_ENDURANCE = 3,
  RaceTypeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RaceTypeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RaceTypeType_IsValid(int value);
constexpr RaceTypeType RaceTypeType_MIN = RACE_TYPE_ACCELERATION;
constexpr RaceTypeType RaceTypeType_MAX = RACE_TYPE_ENDURANCE;
constexpr int RaceTypeType_ARRAYSIZE = RaceTypeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RaceTypeType_descriptor();
template<typename T>
inline const std::string& RaceTypeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RaceTypeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RaceTypeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RaceTypeType_descriptor(), enum_t_value);
}
inline bool RaceTypeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RaceTypeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RaceTypeType>(
    RaceTypeType_descriptor(), name, value);
}
enum TlmStatusType : int {
  TLM_STATUS_ON = 0,
  TLM_STATUS_OFF = 1,
  TlmStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TlmStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TlmStatusType_IsValid(int value);
constexpr TlmStatusType TlmStatusType_MIN = TLM_STATUS_ON;
constexpr TlmStatusType TlmStatusType_MAX = TLM_STATUS_OFF;
constexpr int TlmStatusType_ARRAYSIZE = TlmStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TlmStatusType_descriptor();
template<typename T>
inline const std::string& TlmStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TlmStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TlmStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TlmStatusType_descriptor(), enum_t_value);
}
inline bool TlmStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TlmStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TlmStatusType>(
    TlmStatusType_descriptor(), name, value);
}
enum InverterStatusType : int {
  INVERTER_STATUS_OFF = 0,
  INVERTER_STATUS_IDLE = 1,
  INVERTER_STATUS_ON = 2,
  InverterStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InverterStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InverterStatusType_IsValid(int value);
constexpr InverterStatusType InverterStatusType_MIN = INVERTER_STATUS_OFF;
constexpr InverterStatusType InverterStatusType_MAX = INVERTER_STATUS_ON;
constexpr int InverterStatusType_ARRAYSIZE = InverterStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InverterStatusType_descriptor();
template<typename T>
inline const std::string& InverterStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InverterStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InverterStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InverterStatusType_descriptor(), enum_t_value);
}
inline bool InverterStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InverterStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InverterStatusType>(
    InverterStatusType_descriptor(), name, value);
}
enum CarStatusType : int {
  CAR_STATUS_IDLE = 0,
  CAR_STATUS_SETUP = 1,
  CAR_STATUS_RUN = 2,
  CarStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarStatusType_IsValid(int value);
constexpr CarStatusType CarStatusType_MIN = CAR_STATUS_IDLE;
constexpr CarStatusType CarStatusType_MAX = CAR_STATUS_RUN;
constexpr int CarStatusType_ARRAYSIZE = CarStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarStatusType_descriptor();
template<typename T>
inline const std::string& CarStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarStatusType_descriptor(), enum_t_value);
}
inline bool CarStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarStatusType>(
    CarStatusType_descriptor(), name, value);
}
enum TsStatusType : int {
  TS_STATUS_OFF = 0,
  TS_STATUS_PRECHARGE = 1,
  TS_STATUS_ON = 2,
  TS_STATUS_FATAL = 3,
  TsStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TsStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TsStatusType_IsValid(int value);
constexpr TsStatusType TsStatusType_MIN = TS_STATUS_OFF;
constexpr TsStatusType TsStatusType_MAX = TS_STATUS_FATAL;
constexpr int TsStatusType_ARRAYSIZE = TsStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TsStatusType_descriptor();
template<typename T>
inline const std::string& TsStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TsStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TsStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TsStatusType_descriptor(), enum_t_value);
}
inline bool TsStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TsStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TsStatusType>(
    TsStatusType_descriptor(), name, value);
}
enum TsStatusSetType : int {
  TS_STATUS_SET_OFF = 0,
  TS_STATUS_SET_ON = 1,
  TsStatusSetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TsStatusSetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TsStatusSetType_IsValid(int value);
constexpr TsStatusSetType TsStatusSetType_MIN = TS_STATUS_SET_OFF;
constexpr TsStatusSetType TsStatusSetType_MAX = TS_STATUS_SET_ON;
constexpr int TsStatusSetType_ARRAYSIZE = TsStatusSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TsStatusSetType_descriptor();
template<typename T>
inline const std::string& TsStatusSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TsStatusSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TsStatusSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TsStatusSetType_descriptor(), enum_t_value);
}
inline bool TsStatusSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TsStatusSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TsStatusSetType>(
    TsStatusSetType_descriptor(), name, value);
}
enum SetBalancingStatusType : int {
  SET_BALANCING_STATUS_OFF = 0,
  SET_BALANCING_STATUS_ON = 1,
  SetBalancingStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetBalancingStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetBalancingStatusType_IsValid(int value);
constexpr SetBalancingStatusType SetBalancingStatusType_MIN = SET_BALANCING_STATUS_OFF;
constexpr SetBalancingStatusType SetBalancingStatusType_MAX = SET_BALANCING_STATUS_ON;
constexpr int SetBalancingStatusType_ARRAYSIZE = SetBalancingStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetBalancingStatusType_descriptor();
template<typename T>
inline const std::string& SetBalancingStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetBalancingStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetBalancingStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetBalancingStatusType_descriptor(), enum_t_value);
}
inline bool SetBalancingStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetBalancingStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetBalancingStatusType>(
    SetBalancingStatusType_descriptor(), name, value);
}
enum TractionControlType : int {
  TRACTION_CONTROL_OFF = 0,
  TRACTION_CONTROL_SLIP_CONTROL = 1,
  TRACTION_CONTROL_TORQUE_VECTORING = 2,
  TRACTION_CONTROL_COMPLETE = 3,
  TractionControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TractionControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TractionControlType_IsValid(int value);
constexpr TractionControlType TractionControlType_MIN = TRACTION_CONTROL_OFF;
constexpr TractionControlType TractionControlType_MAX = TRACTION_CONTROL_COMPLETE;
constexpr int TractionControlType_ARRAYSIZE = TractionControlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TractionControlType_descriptor();
template<typename T>
inline const std::string& TractionControlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TractionControlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TractionControlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TractionControlType_descriptor(), enum_t_value);
}
inline bool TractionControlType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TractionControlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TractionControlType>(
    TractionControlType_descriptor(), name, value);
}
enum MapType : int {
  MAP_R = 0,
  MAP_D20 = 1,
  MAP_D40 = 2,
  MAP_D60 = 3,
  MAP_D80 = 4,
  MAP_D100 = 5,
  MapType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MapType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MapType_IsValid(int value);
constexpr MapType MapType_MIN = MAP_R;
constexpr MapType MapType_MAX = MAP_D100;
constexpr int MapType_ARRAYSIZE = MapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MapType_descriptor();
template<typename T>
inline const std::string& MapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MapType_descriptor(), enum_t_value);
}
inline bool MapType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MapType>(
    MapType_descriptor(), name, value);
}
enum CarStatusSetType : int {
  CAR_STATUS_SET_IDLE = 0,
  CAR_STATUS_SET_RUN = 1,
  CarStatusSetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CarStatusSetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CarStatusSetType_IsValid(int value);
constexpr CarStatusSetType CarStatusSetType_MIN = CAR_STATUS_SET_IDLE;
constexpr CarStatusSetType CarStatusSetType_MAX = CAR_STATUS_SET_RUN;
constexpr int CarStatusSetType_ARRAYSIZE = CarStatusSetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CarStatusSetType_descriptor();
template<typename T>
inline const std::string& CarStatusSetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CarStatusSetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CarStatusSetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CarStatusSetType_descriptor(), enum_t_value);
}
inline bool CarStatusSetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CarStatusSetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CarStatusSetType>(
    CarStatusSetType_descriptor(), name, value);
}
enum BoundType : int {
  BOUND_SET_MAX = 0,
  BOUND_SET_MIN = 1,
  BoundType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BoundType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BoundType_IsValid(int value);
constexpr BoundType BoundType_MIN = BOUND_SET_MAX;
constexpr BoundType BoundType_MAX = BOUND_SET_MIN;
constexpr int BoundType_ARRAYSIZE = BoundType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoundType_descriptor();
template<typename T>
inline const std::string& BoundType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BoundType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BoundType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BoundType_descriptor(), enum_t_value);
}
inline bool BoundType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BoundType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BoundType>(
    BoundType_descriptor(), name, value);
}
enum PedalType : int {
  PEDAL_ACCELERATOR = 0,
  PEDAL_BRAKE = 1,
  PedalType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PedalType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PedalType_IsValid(int value);
constexpr PedalType PedalType_MIN = PEDAL_ACCELERATOR;
constexpr PedalType PedalType_MAX = PEDAL_BRAKE;
constexpr int PedalType_ARRAYSIZE = PedalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PedalType_descriptor();
template<typename T>
inline const std::string& PedalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PedalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PedalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PedalType_descriptor(), enum_t_value);
}
inline bool PedalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PedalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PedalType>(
    PedalType_descriptor(), name, value);
}
enum BalancingStatusType : int {
  BALANCING_STATUS_OFF = 0,
  BALANCING_STATUS_ON = 1,
  BalancingStatusType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BalancingStatusType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BalancingStatusType_IsValid(int value);
constexpr BalancingStatusType BalancingStatusType_MIN = BALANCING_STATUS_OFF;
constexpr BalancingStatusType BalancingStatusType_MAX = BALANCING_STATUS_ON;
constexpr int BalancingStatusType_ARRAYSIZE = BalancingStatusType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BalancingStatusType_descriptor();
template<typename T>
inline const std::string& BalancingStatusType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BalancingStatusType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BalancingStatusType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BalancingStatusType_descriptor(), enum_t_value);
}
inline bool BalancingStatusType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BalancingStatusType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BalancingStatusType>(
    BalancingStatusType_descriptor(), name, value);
}
// ===================================================================

class SteerVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SteerVersion) */ {
 public:
  inline SteerVersion() : SteerVersion(nullptr) {}
  ~SteerVersion() override;
  explicit constexpr SteerVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SteerVersion(const SteerVersion& from);
  SteerVersion(SteerVersion&& from) noexcept
    : SteerVersion() {
    *this = ::std::move(from);
  }

  inline SteerVersion& operator=(const SteerVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteerVersion& operator=(SteerVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SteerVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const SteerVersion* internal_default_instance() {
    return reinterpret_cast<const SteerVersion*>(
               &_SteerVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SteerVersion& a, SteerVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(SteerVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SteerVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SteerVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SteerVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SteerVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SteerVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteerVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SteerVersion";
  }
  protected:
  explicit SteerVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SteerVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class DasVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.DasVersion) */ {
 public:
  inline DasVersion() : DasVersion(nullptr) {}
  ~DasVersion() override;
  explicit constexpr DasVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DasVersion(const DasVersion& from);
  DasVersion(DasVersion&& from) noexcept
    : DasVersion() {
    *this = ::std::move(from);
  }

  inline DasVersion& operator=(const DasVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline DasVersion& operator=(DasVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DasVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const DasVersion* internal_default_instance() {
    return reinterpret_cast<const DasVersion*>(
               &_DasVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DasVersion& a, DasVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(DasVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DasVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DasVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DasVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DasVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DasVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DasVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.DasVersion";
  }
  protected:
  explicit DasVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.DasVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvVersion) */ {
 public:
  inline HvVersion() : HvVersion(nullptr) {}
  ~HvVersion() override;
  explicit constexpr HvVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvVersion(const HvVersion& from);
  HvVersion(HvVersion&& from) noexcept
    : HvVersion() {
    *this = ::std::move(from);
  }

  inline HvVersion& operator=(const HvVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvVersion& operator=(HvVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvVersion* internal_default_instance() {
    return reinterpret_cast<const HvVersion*>(
               &_HvVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HvVersion& a, HvVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(HvVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvVersion";
  }
  protected:
  explicit HvVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LvVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LvVersion) */ {
 public:
  inline LvVersion() : LvVersion(nullptr) {}
  ~LvVersion() override;
  explicit constexpr LvVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LvVersion(const LvVersion& from);
  LvVersion(LvVersion&& from) noexcept
    : LvVersion() {
    *this = ::std::move(from);
  }

  inline LvVersion& operator=(const LvVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline LvVersion& operator=(LvVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LvVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const LvVersion* internal_default_instance() {
    return reinterpret_cast<const LvVersion*>(
               &_LvVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LvVersion& a, LvVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(LvVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LvVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LvVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LvVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LvVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LvVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LvVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LvVersion";
  }
  protected:
  explicit LvVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LvVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TlmVersion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TlmVersion) */ {
 public:
  inline TlmVersion() : TlmVersion(nullptr) {}
  ~TlmVersion() override;
  explicit constexpr TlmVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TlmVersion(const TlmVersion& from);
  TlmVersion(TlmVersion&& from) noexcept
    : TlmVersion() {
    *this = ::std::move(from);
  }

  inline TlmVersion& operator=(const TlmVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline TlmVersion& operator=(TlmVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TlmVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const TlmVersion* internal_default_instance() {
    return reinterpret_cast<const TlmVersion*>(
               &_TlmVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TlmVersion& a, TlmVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(TlmVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TlmVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TlmVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TlmVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TlmVersion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TlmVersion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlmVersion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TlmVersion";
  }
  protected:
  explicit TlmVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComponentVersionFieldNumber = 1,
    kCancicdVersionFieldNumber = 2,
  };
  // uint32 component_version = 1;
  void clear_component_version();
  uint32_t component_version() const;
  void set_component_version(uint32_t value);
  private:
  uint32_t _internal_component_version() const;
  void _internal_set_component_version(uint32_t value);
  public:

  // uint32 cancicd_version = 2;
  void clear_cancicd_version();
  uint32_t cancicd_version() const;
  void set_cancicd_version(uint32_t value);
  private:
  uint32_t _internal_cancicd_version() const;
  void _internal_set_cancicd_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TlmVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t component_version_;
  uint32_t cancicd_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit constexpr Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Timestamp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint32 timestamp = 1;
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SetTlmStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SetTlmStatus) */ {
 public:
  inline SetTlmStatus() : SetTlmStatus(nullptr) {}
  ~SetTlmStatus() override;
  explicit constexpr SetTlmStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTlmStatus(const SetTlmStatus& from);
  SetTlmStatus(SetTlmStatus&& from) noexcept
    : SetTlmStatus() {
    *this = ::std::move(from);
  }

  inline SetTlmStatus& operator=(const SetTlmStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTlmStatus& operator=(SetTlmStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTlmStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTlmStatus* internal_default_instance() {
    return reinterpret_cast<const SetTlmStatus*>(
               &_SetTlmStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetTlmStatus& a, SetTlmStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTlmStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTlmStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTlmStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTlmStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTlmStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetTlmStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTlmStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SetTlmStatus";
  }
  protected:
  explicit SetTlmStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTlmStatusSetFieldNumber = 1,
    kRaceTypeFieldNumber = 2,
    kDriverFieldNumber = 3,
    kCircuitFieldNumber = 4,
  };
  // .primary.TlmStatusSetType tlm_status_set = 1;
  void clear_tlm_status_set();
  ::primary::TlmStatusSetType tlm_status_set() const;
  void set_tlm_status_set(::primary::TlmStatusSetType value);
  private:
  ::primary::TlmStatusSetType _internal_tlm_status_set() const;
  void _internal_set_tlm_status_set(::primary::TlmStatusSetType value);
  public:

  // .primary.RaceTypeType race_type = 2;
  void clear_race_type();
  ::primary::RaceTypeType race_type() const;
  void set_race_type(::primary::RaceTypeType value);
  private:
  ::primary::RaceTypeType _internal_race_type() const;
  void _internal_set_race_type(::primary::RaceTypeType value);
  public:

  // uint32 driver = 3;
  void clear_driver();
  uint32_t driver() const;
  void set_driver(uint32_t value);
  private:
  uint32_t _internal_driver() const;
  void _internal_set_driver(uint32_t value);
  public:

  // uint32 circuit = 4;
  void clear_circuit();
  uint32_t circuit() const;
  void set_circuit(uint32_t value);
  private:
  uint32_t _internal_circuit() const;
  void _internal_set_circuit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SetTlmStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int tlm_status_set_;
  int race_type_;
  uint32_t driver_;
  uint32_t circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SteerSystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SteerSystemStatus) */ {
 public:
  inline SteerSystemStatus() : SteerSystemStatus(nullptr) {}
  ~SteerSystemStatus() override;
  explicit constexpr SteerSystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SteerSystemStatus(const SteerSystemStatus& from);
  SteerSystemStatus(SteerSystemStatus&& from) noexcept
    : SteerSystemStatus() {
    *this = ::std::move(from);
  }

  inline SteerSystemStatus& operator=(const SteerSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteerSystemStatus& operator=(SteerSystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SteerSystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SteerSystemStatus* internal_default_instance() {
    return reinterpret_cast<const SteerSystemStatus*>(
               &_SteerSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SteerSystemStatus& a, SteerSystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SteerSystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SteerSystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SteerSystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SteerSystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SteerSystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SteerSystemStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteerSystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SteerSystemStatus";
  }
  protected:
  explicit SteerSystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocTempFieldNumber = 1,
  };
  // uint32 soc_temp = 1;
  void clear_soc_temp();
  uint32_t soc_temp() const;
  void set_soc_temp(uint32_t value);
  private:
  uint32_t _internal_soc_temp() const;
  void _internal_set_soc_temp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SteerSystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t soc_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class Marker final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:primary.Marker) */ {
 public:
  inline Marker() : Marker(nullptr) {}
  explicit constexpr Marker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Marker(const Marker& from);
  Marker(Marker&& from) noexcept
    : Marker() {
    *this = ::std::move(from);
  }

  inline Marker& operator=(const Marker& from) {
    CopyFrom(from);
    return *this;
  }
  inline Marker& operator=(Marker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Marker& default_instance() {
    return *internal_default_instance();
  }
  static inline const Marker* internal_default_instance() {
    return reinterpret_cast<const Marker*>(
               &_Marker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Marker& a, Marker& b) {
    a.Swap(&b);
  }
  inline void Swap(Marker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Marker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Marker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Marker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Marker& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Marker& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.Marker";
  }
  protected:
  explicit Marker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:primary.Marker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TlmStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TlmStatus) */ {
 public:
  inline TlmStatus() : TlmStatus(nullptr) {}
  ~TlmStatus() override;
  explicit constexpr TlmStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TlmStatus(const TlmStatus& from);
  TlmStatus(TlmStatus&& from) noexcept
    : TlmStatus() {
    *this = ::std::move(from);
  }

  inline TlmStatus& operator=(const TlmStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TlmStatus& operator=(TlmStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TlmStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TlmStatus* internal_default_instance() {
    return reinterpret_cast<const TlmStatus*>(
               &_TlmStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TlmStatus& a, TlmStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TlmStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TlmStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TlmStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TlmStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TlmStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TlmStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TlmStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TlmStatus";
  }
  protected:
  explicit TlmStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTlmStatusFieldNumber = 1,
    kRaceTypeFieldNumber = 2,
    kDriverFieldNumber = 3,
    kCircuitFieldNumber = 4,
  };
  // .primary.TlmStatusType tlm_status = 1;
  void clear_tlm_status();
  ::primary::TlmStatusType tlm_status() const;
  void set_tlm_status(::primary::TlmStatusType value);
  private:
  ::primary::TlmStatusType _internal_tlm_status() const;
  void _internal_set_tlm_status(::primary::TlmStatusType value);
  public:

  // .primary.RaceTypeType race_type = 2;
  void clear_race_type();
  ::primary::RaceTypeType race_type() const;
  void set_race_type(::primary::RaceTypeType value);
  private:
  ::primary::RaceTypeType _internal_race_type() const;
  void _internal_set_race_type(::primary::RaceTypeType value);
  public:

  // uint32 driver = 3;
  void clear_driver();
  uint32_t driver() const;
  void set_driver(uint32_t value);
  private:
  uint32_t _internal_driver() const;
  void _internal_set_driver(uint32_t value);
  public:

  // uint32 circuit = 4;
  void clear_circuit();
  uint32_t circuit() const;
  void set_circuit(uint32_t value);
  private:
  uint32_t _internal_circuit() const;
  void _internal_set_circuit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TlmStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int tlm_status_;
  int race_type_;
  uint32_t driver_;
  uint32_t circuit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class CarStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.CarStatus) */ {
 public:
  inline CarStatus() : CarStatus(nullptr) {}
  ~CarStatus() override;
  explicit constexpr CarStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarStatus(const CarStatus& from);
  CarStatus(CarStatus&& from) noexcept
    : CarStatus() {
    *this = ::std::move(from);
  }

  inline CarStatus& operator=(const CarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarStatus& operator=(CarStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarStatus* internal_default_instance() {
    return reinterpret_cast<const CarStatus*>(
               &_CarStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CarStatus& a, CarStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CarStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CarStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.CarStatus";
  }
  protected:
  explicit CarStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInverterLFieldNumber = 1,
    kInverterRFieldNumber = 2,
    kCarStatusFieldNumber = 3,
  };
  // .primary.InverterStatusType inverter_l = 1;
  void clear_inverter_l();
  ::primary::InverterStatusType inverter_l() const;
  void set_inverter_l(::primary::InverterStatusType value);
  private:
  ::primary::InverterStatusType _internal_inverter_l() const;
  void _internal_set_inverter_l(::primary::InverterStatusType value);
  public:

  // .primary.InverterStatusType inverter_r = 2;
  void clear_inverter_r();
  ::primary::InverterStatusType inverter_r() const;
  void set_inverter_r(::primary::InverterStatusType value);
  private:
  ::primary::InverterStatusType _internal_inverter_r() const;
  void _internal_set_inverter_r(::primary::InverterStatusType value);
  public:

  // .primary.CarStatusType car_status = 3;
  void clear_car_status();
  ::primary::CarStatusType car_status() const;
  void set_car_status(::primary::CarStatusType value);
  private:
  ::primary::CarStatusType _internal_car_status() const;
  void _internal_set_car_status(::primary::CarStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.CarStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int inverter_l_;
  int inverter_r_;
  int car_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class DasErrors final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.DasErrors) */ {
 public:
  inline DasErrors() : DasErrors(nullptr) {}
  ~DasErrors() override;
  explicit constexpr DasErrors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DasErrors(const DasErrors& from);
  DasErrors(DasErrors&& from) noexcept
    : DasErrors() {
    *this = ::std::move(from);
  }

  inline DasErrors& operator=(const DasErrors& from) {
    CopyFrom(from);
    return *this;
  }
  inline DasErrors& operator=(DasErrors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DasErrors& default_instance() {
    return *internal_default_instance();
  }
  static inline const DasErrors* internal_default_instance() {
    return reinterpret_cast<const DasErrors*>(
               &_DasErrors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DasErrors& a, DasErrors& b) {
    a.Swap(&b);
  }
  inline void Swap(DasErrors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DasErrors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DasErrors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DasErrors>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DasErrors& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DasErrors& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DasErrors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.DasErrors";
  }
  protected:
  explicit DasErrors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDasErrorFieldNumber = 1,
  };
  // uint32 das_error = 1;
  void clear_das_error();
  uint32_t das_error() const;
  void set_das_error(uint32_t value);
  private:
  uint32_t _internal_das_error() const;
  void _internal_set_das_error(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.DasErrors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t das_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class Speed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.Speed) */ {
 public:
  inline Speed() : Speed(nullptr) {}
  ~Speed() override;
  explicit constexpr Speed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Speed(const Speed& from);
  Speed(Speed&& from) noexcept
    : Speed() {
    *this = ::std::move(from);
  }

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }
  inline Speed& operator=(Speed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Speed& default_instance() {
    return *internal_default_instance();
  }
  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Speed& a, Speed& b) {
    a.Swap(&b);
  }
  inline void Swap(Speed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Speed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Speed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Speed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Speed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Speed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Speed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.Speed";
  }
  protected:
  explicit Speed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncoderRFieldNumber = 1,
    kEncoderLFieldNumber = 2,
    kInverterRFieldNumber = 3,
    kInverterLFieldNumber = 4,
  };
  // uint32 encoder_r = 1;
  void clear_encoder_r();
  uint32_t encoder_r() const;
  void set_encoder_r(uint32_t value);
  private:
  uint32_t _internal_encoder_r() const;
  void _internal_set_encoder_r(uint32_t value);
  public:

  // uint32 encoder_l = 2;
  void clear_encoder_l();
  uint32_t encoder_l() const;
  void set_encoder_l(uint32_t value);
  private:
  uint32_t _internal_encoder_l() const;
  void _internal_set_encoder_l(uint32_t value);
  public:

  // uint32 inverter_r = 3;
  void clear_inverter_r();
  uint32_t inverter_r() const;
  void set_inverter_r(uint32_t value);
  private:
  uint32_t _internal_inverter_r() const;
  void _internal_set_inverter_r(uint32_t value);
  public:

  // uint32 inverter_l = 4;
  void clear_inverter_l();
  uint32_t inverter_l() const;
  void set_inverter_l(uint32_t value);
  private:
  uint32_t _internal_inverter_l() const;
  void _internal_set_inverter_l(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.Speed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t encoder_r_;
  uint32_t encoder_l_;
  uint32_t inverter_r_;
  uint32_t inverter_l_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvVoltage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvVoltage) */ {
 public:
  inline HvVoltage() : HvVoltage(nullptr) {}
  ~HvVoltage() override;
  explicit constexpr HvVoltage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvVoltage(const HvVoltage& from);
  HvVoltage(HvVoltage&& from) noexcept
    : HvVoltage() {
    *this = ::std::move(from);
  }

  inline HvVoltage& operator=(const HvVoltage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvVoltage& operator=(HvVoltage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvVoltage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvVoltage* internal_default_instance() {
    return reinterpret_cast<const HvVoltage*>(
               &_HvVoltage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HvVoltage& a, HvVoltage& b) {
    a.Swap(&b);
  }
  inline void Swap(HvVoltage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvVoltage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvVoltage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvVoltage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvVoltage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvVoltage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvVoltage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvVoltage";
  }
  protected:
  explicit HvVoltage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackVoltageFieldNumber = 1,
    kBusVoltageFieldNumber = 2,
    kMaxCellVoltageFieldNumber = 3,
    kMinCellVoltageFieldNumber = 4,
  };
  // uint32 pack_voltage = 1;
  void clear_pack_voltage();
  uint32_t pack_voltage() const;
  void set_pack_voltage(uint32_t value);
  private:
  uint32_t _internal_pack_voltage() const;
  void _internal_set_pack_voltage(uint32_t value);
  public:

  // uint32 bus_voltage = 2;
  void clear_bus_voltage();
  uint32_t bus_voltage() const;
  void set_bus_voltage(uint32_t value);
  private:
  uint32_t _internal_bus_voltage() const;
  void _internal_set_bus_voltage(uint32_t value);
  public:

  // uint32 max_cell_voltage = 3;
  void clear_max_cell_voltage();
  uint32_t max_cell_voltage() const;
  void set_max_cell_voltage(uint32_t value);
  private:
  uint32_t _internal_max_cell_voltage() const;
  void _internal_set_max_cell_voltage(uint32_t value);
  public:

  // uint32 min_cell_voltage = 4;
  void clear_min_cell_voltage();
  uint32_t min_cell_voltage() const;
  void set_min_cell_voltage(uint32_t value);
  private:
  uint32_t _internal_min_cell_voltage() const;
  void _internal_set_min_cell_voltage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvVoltage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t pack_voltage_;
  uint32_t bus_voltage_;
  uint32_t max_cell_voltage_;
  uint32_t min_cell_voltage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvCurrent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvCurrent) */ {
 public:
  inline HvCurrent() : HvCurrent(nullptr) {}
  ~HvCurrent() override;
  explicit constexpr HvCurrent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvCurrent(const HvCurrent& from);
  HvCurrent(HvCurrent&& from) noexcept
    : HvCurrent() {
    *this = ::std::move(from);
  }

  inline HvCurrent& operator=(const HvCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvCurrent& operator=(HvCurrent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvCurrent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvCurrent* internal_default_instance() {
    return reinterpret_cast<const HvCurrent*>(
               &_HvCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HvCurrent& a, HvCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(HvCurrent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvCurrent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvCurrent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvCurrent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvCurrent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvCurrent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvCurrent";
  }
  protected:
  explicit HvCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
    kPowerFieldNumber = 2,
  };
  // uint32 current = 1;
  void clear_current();
  uint32_t current() const;
  void set_current(uint32_t value);
  private:
  uint32_t _internal_current() const;
  void _internal_set_current(uint32_t value);
  public:

  // int32 power = 2;
  void clear_power();
  int32_t power() const;
  void set_power(int32_t value);
  private:
  int32_t _internal_power() const;
  void _internal_set_power(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvCurrent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t current_;
  int32_t power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvTemp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvTemp) */ {
 public:
  inline HvTemp() : HvTemp(nullptr) {}
  ~HvTemp() override;
  explicit constexpr HvTemp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvTemp(const HvTemp& from);
  HvTemp(HvTemp&& from) noexcept
    : HvTemp() {
    *this = ::std::move(from);
  }

  inline HvTemp& operator=(const HvTemp& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvTemp& operator=(HvTemp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvTemp& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvTemp* internal_default_instance() {
    return reinterpret_cast<const HvTemp*>(
               &_HvTemp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HvTemp& a, HvTemp& b) {
    a.Swap(&b);
  }
  inline void Swap(HvTemp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvTemp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvTemp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvTemp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvTemp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvTemp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvTemp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvTemp";
  }
  protected:
  explicit HvTemp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAverageTempFieldNumber = 1,
    kMaxTempFieldNumber = 2,
    kMinTempFieldNumber = 3,
  };
  // uint32 average_temp = 1;
  void clear_average_temp();
  uint32_t average_temp() const;
  void set_average_temp(uint32_t value);
  private:
  uint32_t _internal_average_temp() const;
  void _internal_set_average_temp(uint32_t value);
  public:

  // uint32 max_temp = 2;
  void clear_max_temp();
  uint32_t max_temp() const;
  void set_max_temp(uint32_t value);
  private:
  uint32_t _internal_max_temp() const;
  void _internal_set_max_temp(uint32_t value);
  public:

  // uint32 min_temp = 3;
  void clear_min_temp();
  uint32_t min_temp() const;
  void set_min_temp(uint32_t value);
  private:
  uint32_t _internal_min_temp() const;
  void _internal_set_min_temp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvTemp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t average_temp_;
  uint32_t max_temp_;
  uint32_t min_temp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvErrors final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvErrors) */ {
 public:
  inline HvErrors() : HvErrors(nullptr) {}
  ~HvErrors() override;
  explicit constexpr HvErrors(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvErrors(const HvErrors& from);
  HvErrors(HvErrors&& from) noexcept
    : HvErrors() {
    *this = ::std::move(from);
  }

  inline HvErrors& operator=(const HvErrors& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvErrors& operator=(HvErrors&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvErrors& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvErrors* internal_default_instance() {
    return reinterpret_cast<const HvErrors*>(
               &_HvErrors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HvErrors& a, HvErrors& b) {
    a.Swap(&b);
  }
  inline void Swap(HvErrors* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvErrors* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvErrors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvErrors>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvErrors& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvErrors& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvErrors* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvErrors";
  }
  protected:
  explicit HvErrors(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWarningsFieldNumber = 1,
    kErrorsFieldNumber = 2,
  };
  // uint32 warnings = 1;
  void clear_warnings();
  uint32_t warnings() const;
  void set_warnings(uint32_t value);
  private:
  uint32_t _internal_warnings() const;
  void _internal_set_warnings(uint32_t value);
  public:

  // uint32 errors = 2;
  void clear_errors();
  uint32_t errors() const;
  void set_errors(uint32_t value);
  private:
  uint32_t _internal_errors() const;
  void _internal_set_errors(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvErrors)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t warnings_;
  uint32_t errors_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class TsStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.TsStatus) */ {
 public:
  inline TsStatus() : TsStatus(nullptr) {}
  ~TsStatus() override;
  explicit constexpr TsStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TsStatus(const TsStatus& from);
  TsStatus(TsStatus&& from) noexcept
    : TsStatus() {
    *this = ::std::move(from);
  }

  inline TsStatus& operator=(const TsStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsStatus& operator=(TsStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TsStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TsStatus* internal_default_instance() {
    return reinterpret_cast<const TsStatus*>(
               &_TsStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TsStatus& a, TsStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TsStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TsStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TsStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TsStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TsStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TsStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.TsStatus";
  }
  protected:
  explicit TsStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsStatusFieldNumber = 1,
  };
  // .primary.TsStatusType ts_status = 1;
  void clear_ts_status();
  ::primary::TsStatusType ts_status() const;
  void set_ts_status(::primary::TsStatusType value);
  private:
  ::primary::TsStatusType _internal_ts_status() const;
  void _internal_set_ts_status(::primary::TsStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.TsStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int ts_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SetTsStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SetTsStatus) */ {
 public:
  inline SetTsStatus() : SetTsStatus(nullptr) {}
  ~SetTsStatus() override;
  explicit constexpr SetTsStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetTsStatus(const SetTsStatus& from);
  SetTsStatus(SetTsStatus&& from) noexcept
    : SetTsStatus() {
    *this = ::std::move(from);
  }

  inline SetTsStatus& operator=(const SetTsStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetTsStatus& operator=(SetTsStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetTsStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetTsStatus* internal_default_instance() {
    return reinterpret_cast<const SetTsStatus*>(
               &_SetTsStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetTsStatus& a, SetTsStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SetTsStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetTsStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetTsStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetTsStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetTsStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetTsStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTsStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SetTsStatus";
  }
  protected:
  explicit SetTsStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsStatusSetFieldNumber = 1,
  };
  // .primary.TsStatusSetType ts_status_set = 1;
  void clear_ts_status_set();
  ::primary::TsStatusSetType ts_status_set() const;
  void set_ts_status_set(::primary::TsStatusSetType value);
  private:
  ::primary::TsStatusSetType _internal_ts_status_set() const;
  void _internal_set_ts_status_set(::primary::TsStatusSetType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SetTsStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int ts_status_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SetCellBalancingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SetCellBalancingStatus) */ {
 public:
  inline SetCellBalancingStatus() : SetCellBalancingStatus(nullptr) {}
  ~SetCellBalancingStatus() override;
  explicit constexpr SetCellBalancingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCellBalancingStatus(const SetCellBalancingStatus& from);
  SetCellBalancingStatus(SetCellBalancingStatus&& from) noexcept
    : SetCellBalancingStatus() {
    *this = ::std::move(from);
  }

  inline SetCellBalancingStatus& operator=(const SetCellBalancingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCellBalancingStatus& operator=(SetCellBalancingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCellBalancingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCellBalancingStatus* internal_default_instance() {
    return reinterpret_cast<const SetCellBalancingStatus*>(
               &_SetCellBalancingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetCellBalancingStatus& a, SetCellBalancingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCellBalancingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCellBalancingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCellBalancingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCellBalancingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCellBalancingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetCellBalancingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCellBalancingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SetCellBalancingStatus";
  }
  protected:
  explicit SetCellBalancingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetBalancingStatusFieldNumber = 1,
  };
  // .primary.SetBalancingStatusType set_balancing_status = 1;
  void clear_set_balancing_status();
  ::primary::SetBalancingStatusType set_balancing_status() const;
  void set_set_balancing_status(::primary::SetBalancingStatusType value);
  private:
  ::primary::SetBalancingStatusType _internal_set_balancing_status() const;
  void _internal_set_set_balancing_status(::primary::SetBalancingStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SetCellBalancingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int set_balancing_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HandcartStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HandcartStatus) */ {
 public:
  inline HandcartStatus() : HandcartStatus(nullptr) {}
  ~HandcartStatus() override;
  explicit constexpr HandcartStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandcartStatus(const HandcartStatus& from);
  HandcartStatus(HandcartStatus&& from) noexcept
    : HandcartStatus() {
    *this = ::std::move(from);
  }

  inline HandcartStatus& operator=(const HandcartStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandcartStatus& operator=(HandcartStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandcartStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandcartStatus* internal_default_instance() {
    return reinterpret_cast<const HandcartStatus*>(
               &_HandcartStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HandcartStatus& a, HandcartStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(HandcartStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandcartStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandcartStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandcartStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandcartStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HandcartStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandcartStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HandcartStatus";
  }
  protected:
  explicit HandcartStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HandcartStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool connected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SteerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SteerStatus) */ {
 public:
  inline SteerStatus() : SteerStatus(nullptr) {}
  ~SteerStatus() override;
  explicit constexpr SteerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SteerStatus(const SteerStatus& from);
  SteerStatus(SteerStatus&& from) noexcept
    : SteerStatus() {
    *this = ::std::move(from);
  }

  inline SteerStatus& operator=(const SteerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SteerStatus& operator=(SteerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SteerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SteerStatus* internal_default_instance() {
    return reinterpret_cast<const SteerStatus*>(
               &_SteerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SteerStatus& a, SteerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SteerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SteerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SteerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SteerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SteerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SteerStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SteerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SteerStatus";
  }
  protected:
  explicit SteerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTractionControlFieldNumber = 1,
    kMapFieldNumber = 2,
  };
  // .primary.TractionControlType traction_control = 1;
  void clear_traction_control();
  ::primary::TractionControlType traction_control() const;
  void set_traction_control(::primary::TractionControlType value);
  private:
  ::primary::TractionControlType _internal_traction_control() const;
  void _internal_set_traction_control(::primary::TractionControlType value);
  public:

  // .primary.MapType map = 2;
  void clear_map();
  ::primary::MapType map() const;
  void set_map(::primary::MapType value);
  private:
  ::primary::MapType _internal_map() const;
  void _internal_set_map(::primary::MapType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SteerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int traction_control_;
  int map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SetCarStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SetCarStatus) */ {
 public:
  inline SetCarStatus() : SetCarStatus(nullptr) {}
  ~SetCarStatus() override;
  explicit constexpr SetCarStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetCarStatus(const SetCarStatus& from);
  SetCarStatus(SetCarStatus&& from) noexcept
    : SetCarStatus() {
    *this = ::std::move(from);
  }

  inline SetCarStatus& operator=(const SetCarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCarStatus& operator=(SetCarStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCarStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCarStatus* internal_default_instance() {
    return reinterpret_cast<const SetCarStatus*>(
               &_SetCarStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SetCarStatus& a, SetCarStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCarStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCarStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCarStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCarStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetCarStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetCarStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetCarStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SetCarStatus";
  }
  protected:
  explicit SetCarStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCarStatusSetFieldNumber = 1,
  };
  // .primary.CarStatusSetType car_status_set = 1;
  void clear_car_status_set();
  ::primary::CarStatusSetType car_status_set() const;
  void set_car_status_set(::primary::CarStatusSetType value);
  private:
  ::primary::CarStatusSetType _internal_car_status_set() const;
  void _internal_set_car_status_set(::primary::CarStatusSetType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SetCarStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int car_status_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class SetPedalsRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.SetPedalsRange) */ {
 public:
  inline SetPedalsRange() : SetPedalsRange(nullptr) {}
  ~SetPedalsRange() override;
  explicit constexpr SetPedalsRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPedalsRange(const SetPedalsRange& from);
  SetPedalsRange(SetPedalsRange&& from) noexcept
    : SetPedalsRange() {
    *this = ::std::move(from);
  }

  inline SetPedalsRange& operator=(const SetPedalsRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPedalsRange& operator=(SetPedalsRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPedalsRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPedalsRange* internal_default_instance() {
    return reinterpret_cast<const SetPedalsRange*>(
               &_SetPedalsRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SetPedalsRange& a, SetPedalsRange& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPedalsRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPedalsRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPedalsRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPedalsRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPedalsRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetPedalsRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPedalsRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.SetPedalsRange";
  }
  protected:
  explicit SetPedalsRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoundFieldNumber = 1,
    kPedalFieldNumber = 2,
  };
  // .primary.BoundType bound = 1;
  void clear_bound();
  ::primary::BoundType bound() const;
  void set_bound(::primary::BoundType value);
  private:
  ::primary::BoundType _internal_bound() const;
  void _internal_set_bound(::primary::BoundType value);
  public:

  // .primary.PedalType pedal = 2;
  void clear_pedal();
  ::primary::PedalType pedal() const;
  void set_pedal(::primary::PedalType value);
  private:
  ::primary::PedalType _internal_pedal() const;
  void _internal_set_pedal(::primary::PedalType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.SetPedalsRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int bound_;
  int pedal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LvCurrent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LvCurrent) */ {
 public:
  inline LvCurrent() : LvCurrent(nullptr) {}
  ~LvCurrent() override;
  explicit constexpr LvCurrent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LvCurrent(const LvCurrent& from);
  LvCurrent(LvCurrent&& from) noexcept
    : LvCurrent() {
    *this = ::std::move(from);
  }

  inline LvCurrent& operator=(const LvCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LvCurrent& operator=(LvCurrent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LvCurrent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LvCurrent* internal_default_instance() {
    return reinterpret_cast<const LvCurrent*>(
               &_LvCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LvCurrent& a, LvCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(LvCurrent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LvCurrent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LvCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LvCurrent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LvCurrent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LvCurrent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LvCurrent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LvCurrent";
  }
  protected:
  explicit LvCurrent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentFieldNumber = 1,
  };
  // uint32 current = 1;
  void clear_current();
  uint32_t current() const;
  void set_current(uint32_t value);
  private:
  uint32_t _internal_current() const;
  void _internal_set_current(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LvCurrent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t current_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LvVoltage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LvVoltage) */ {
 public:
  inline LvVoltage() : LvVoltage(nullptr) {}
  ~LvVoltage() override;
  explicit constexpr LvVoltage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LvVoltage(const LvVoltage& from);
  LvVoltage(LvVoltage&& from) noexcept
    : LvVoltage() {
    *this = ::std::move(from);
  }

  inline LvVoltage& operator=(const LvVoltage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LvVoltage& operator=(LvVoltage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LvVoltage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LvVoltage* internal_default_instance() {
    return reinterpret_cast<const LvVoltage*>(
               &_LvVoltage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LvVoltage& a, LvVoltage& b) {
    a.Swap(&b);
  }
  inline void Swap(LvVoltage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LvVoltage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LvVoltage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LvVoltage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LvVoltage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LvVoltage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LvVoltage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LvVoltage";
  }
  protected:
  explicit LvVoltage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalVoltageFieldNumber = 1,
    kVoltage1FieldNumber = 2,
    kVoltage2FieldNumber = 3,
    kVoltage3FieldNumber = 4,
    kVoltage4FieldNumber = 5,
  };
  // uint32 total_voltage = 1;
  void clear_total_voltage();
  uint32_t total_voltage() const;
  void set_total_voltage(uint32_t value);
  private:
  uint32_t _internal_total_voltage() const;
  void _internal_set_total_voltage(uint32_t value);
  public:

  // uint32 voltage_1 = 2;
  void clear_voltage_1();
  uint32_t voltage_1() const;
  void set_voltage_1(uint32_t value);
  private:
  uint32_t _internal_voltage_1() const;
  void _internal_set_voltage_1(uint32_t value);
  public:

  // uint32 voltage_2 = 3;
  void clear_voltage_2();
  uint32_t voltage_2() const;
  void set_voltage_2(uint32_t value);
  private:
  uint32_t _internal_voltage_2() const;
  void _internal_set_voltage_2(uint32_t value);
  public:

  // uint32 voltage_3 = 4;
  void clear_voltage_3();
  uint32_t voltage_3() const;
  void set_voltage_3(uint32_t value);
  private:
  uint32_t _internal_voltage_3() const;
  void _internal_set_voltage_3(uint32_t value);
  public:

  // uint32 voltage_4 = 5;
  void clear_voltage_4();
  uint32_t voltage_4() const;
  void set_voltage_4(uint32_t value);
  private:
  uint32_t _internal_voltage_4() const;
  void _internal_set_voltage_4(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LvVoltage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t total_voltage_;
  uint32_t voltage_1_;
  uint32_t voltage_2_;
  uint32_t voltage_3_;
  uint32_t voltage_4_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class LvTemperature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.LvTemperature) */ {
 public:
  inline LvTemperature() : LvTemperature(nullptr) {}
  ~LvTemperature() override;
  explicit constexpr LvTemperature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LvTemperature(const LvTemperature& from);
  LvTemperature(LvTemperature&& from) noexcept
    : LvTemperature() {
    *this = ::std::move(from);
  }

  inline LvTemperature& operator=(const LvTemperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline LvTemperature& operator=(LvTemperature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LvTemperature& default_instance() {
    return *internal_default_instance();
  }
  static inline const LvTemperature* internal_default_instance() {
    return reinterpret_cast<const LvTemperature*>(
               &_LvTemperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LvTemperature& a, LvTemperature& b) {
    a.Swap(&b);
  }
  inline void Swap(LvTemperature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LvTemperature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LvTemperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LvTemperature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LvTemperature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LvTemperature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LvTemperature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.LvTemperature";
  }
  protected:
  explicit LvTemperature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBpTemperatureFieldNumber = 1,
    kDcdcTemperatureFieldNumber = 2,
  };
  // uint32 bp_temperature = 1;
  void clear_bp_temperature();
  uint32_t bp_temperature() const;
  void set_bp_temperature(uint32_t value);
  private:
  uint32_t _internal_bp_temperature() const;
  void _internal_set_bp_temperature(uint32_t value);
  public:

  // uint32 dcdc_temperature = 2;
  void clear_dcdc_temperature();
  uint32_t dcdc_temperature() const;
  void set_dcdc_temperature(uint32_t value);
  private:
  uint32_t _internal_dcdc_temperature() const;
  void _internal_set_dcdc_temperature(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.LvTemperature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t bp_temperature_;
  uint32_t dcdc_temperature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class CoolingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.CoolingStatus) */ {
 public:
  inline CoolingStatus() : CoolingStatus(nullptr) {}
  ~CoolingStatus() override;
  explicit constexpr CoolingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoolingStatus(const CoolingStatus& from);
  CoolingStatus(CoolingStatus&& from) noexcept
    : CoolingStatus() {
    *this = ::std::move(from);
  }

  inline CoolingStatus& operator=(const CoolingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoolingStatus& operator=(CoolingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoolingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoolingStatus* internal_default_instance() {
    return reinterpret_cast<const CoolingStatus*>(
               &_CoolingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CoolingStatus& a, CoolingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CoolingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoolingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoolingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoolingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoolingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CoolingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoolingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.CoolingStatus";
  }
  protected:
  explicit CoolingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHvFanSpeedFieldNumber = 1,
    kLvFanSpeedFieldNumber = 2,
    kPumpSpeedFieldNumber = 3,
  };
  // uint32 hv_fan_speed = 1;
  void clear_hv_fan_speed();
  uint32_t hv_fan_speed() const;
  void set_hv_fan_speed(uint32_t value);
  private:
  uint32_t _internal_hv_fan_speed() const;
  void _internal_set_hv_fan_speed(uint32_t value);
  public:

  // uint32 lv_fan_speed = 2;
  void clear_lv_fan_speed();
  uint32_t lv_fan_speed() const;
  void set_lv_fan_speed(uint32_t value);
  private:
  uint32_t _internal_lv_fan_speed() const;
  void _internal_set_lv_fan_speed(uint32_t value);
  public:

  // uint32 pump_speed = 3;
  void clear_pump_speed();
  uint32_t pump_speed() const;
  void set_pump_speed(uint32_t value);
  private:
  uint32_t _internal_pump_speed() const;
  void _internal_set_pump_speed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.CoolingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t hv_fan_speed_;
  uint32_t lv_fan_speed_;
  uint32_t pump_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvCellsVoltage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvCellsVoltage) */ {
 public:
  inline HvCellsVoltage() : HvCellsVoltage(nullptr) {}
  ~HvCellsVoltage() override;
  explicit constexpr HvCellsVoltage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvCellsVoltage(const HvCellsVoltage& from);
  HvCellsVoltage(HvCellsVoltage&& from) noexcept
    : HvCellsVoltage() {
    *this = ::std::move(from);
  }

  inline HvCellsVoltage& operator=(const HvCellsVoltage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvCellsVoltage& operator=(HvCellsVoltage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvCellsVoltage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvCellsVoltage* internal_default_instance() {
    return reinterpret_cast<const HvCellsVoltage*>(
               &_HvCellsVoltage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(HvCellsVoltage& a, HvCellsVoltage& b) {
    a.Swap(&b);
  }
  inline void Swap(HvCellsVoltage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvCellsVoltage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvCellsVoltage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvCellsVoltage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvCellsVoltage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvCellsVoltage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvCellsVoltage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvCellsVoltage";
  }
  protected:
  explicit HvCellsVoltage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIndexFieldNumber = 1,
    kVoltage0FieldNumber = 2,
    kVoltage1FieldNumber = 3,
    kVoltage2FieldNumber = 4,
  };
  // uint32 cell_index = 1;
  void clear_cell_index();
  uint32_t cell_index() const;
  void set_cell_index(uint32_t value);
  private:
  uint32_t _internal_cell_index() const;
  void _internal_set_cell_index(uint32_t value);
  public:

  // uint32 voltage_0 = 2;
  void clear_voltage_0();
  uint32_t voltage_0() const;
  void set_voltage_0(uint32_t value);
  private:
  uint32_t _internal_voltage_0() const;
  void _internal_set_voltage_0(uint32_t value);
  public:

  // uint32 voltage_1 = 3;
  void clear_voltage_1();
  uint32_t voltage_1() const;
  void set_voltage_1(uint32_t value);
  private:
  uint32_t _internal_voltage_1() const;
  void _internal_set_voltage_1(uint32_t value);
  public:

  // uint32 voltage_2 = 4;
  void clear_voltage_2();
  uint32_t voltage_2() const;
  void set_voltage_2(uint32_t value);
  private:
  uint32_t _internal_voltage_2() const;
  void _internal_set_voltage_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvCellsVoltage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t cell_index_;
  uint32_t voltage_0_;
  uint32_t voltage_1_;
  uint32_t voltage_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvCellsTemp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvCellsTemp) */ {
 public:
  inline HvCellsTemp() : HvCellsTemp(nullptr) {}
  ~HvCellsTemp() override;
  explicit constexpr HvCellsTemp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvCellsTemp(const HvCellsTemp& from);
  HvCellsTemp(HvCellsTemp&& from) noexcept
    : HvCellsTemp() {
    *this = ::std::move(from);
  }

  inline HvCellsTemp& operator=(const HvCellsTemp& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvCellsTemp& operator=(HvCellsTemp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvCellsTemp& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvCellsTemp* internal_default_instance() {
    return reinterpret_cast<const HvCellsTemp*>(
               &_HvCellsTemp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(HvCellsTemp& a, HvCellsTemp& b) {
    a.Swap(&b);
  }
  inline void Swap(HvCellsTemp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvCellsTemp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvCellsTemp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvCellsTemp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvCellsTemp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvCellsTemp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvCellsTemp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvCellsTemp";
  }
  protected:
  explicit HvCellsTemp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellIndexFieldNumber = 1,
    kTemp0FieldNumber = 2,
    kTemp1FieldNumber = 3,
    kTemp2FieldNumber = 4,
    kTemp3FieldNumber = 5,
    kTemp4FieldNumber = 6,
    kTemp5FieldNumber = 7,
    kTemp6FieldNumber = 8,
  };
  // uint32 cell_index = 1;
  void clear_cell_index();
  uint32_t cell_index() const;
  void set_cell_index(uint32_t value);
  private:
  uint32_t _internal_cell_index() const;
  void _internal_set_cell_index(uint32_t value);
  public:

  // uint32 temp_0 = 2;
  void clear_temp_0();
  uint32_t temp_0() const;
  void set_temp_0(uint32_t value);
  private:
  uint32_t _internal_temp_0() const;
  void _internal_set_temp_0(uint32_t value);
  public:

  // uint32 temp_1 = 3;
  void clear_temp_1();
  uint32_t temp_1() const;
  void set_temp_1(uint32_t value);
  private:
  uint32_t _internal_temp_1() const;
  void _internal_set_temp_1(uint32_t value);
  public:

  // uint32 temp_2 = 4;
  void clear_temp_2();
  uint32_t temp_2() const;
  void set_temp_2(uint32_t value);
  private:
  uint32_t _internal_temp_2() const;
  void _internal_set_temp_2(uint32_t value);
  public:

  // uint32 temp_3 = 5;
  void clear_temp_3();
  uint32_t temp_3() const;
  void set_temp_3(uint32_t value);
  private:
  uint32_t _internal_temp_3() const;
  void _internal_set_temp_3(uint32_t value);
  public:

  // uint32 temp_4 = 6;
  void clear_temp_4();
  uint32_t temp_4() const;
  void set_temp_4(uint32_t value);
  private:
  uint32_t _internal_temp_4() const;
  void _internal_set_temp_4(uint32_t value);
  public:

  // uint32 temp_5 = 7;
  void clear_temp_5();
  uint32_t temp_5() const;
  void set_temp_5(uint32_t value);
  private:
  uint32_t _internal_temp_5() const;
  void _internal_set_temp_5(uint32_t value);
  public:

  // uint32 temp_6 = 8;
  void clear_temp_6();
  uint32_t temp_6() const;
  void set_temp_6(uint32_t value);
  private:
  uint32_t _internal_temp_6() const;
  void _internal_set_temp_6(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvCellsTemp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t cell_index_;
  uint32_t temp_0_;
  uint32_t temp_1_;
  uint32_t temp_2_;
  uint32_t temp_3_;
  uint32_t temp_4_;
  uint32_t temp_5_;
  uint32_t temp_6_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class HvCellBalancingStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.HvCellBalancingStatus) */ {
 public:
  inline HvCellBalancingStatus() : HvCellBalancingStatus(nullptr) {}
  ~HvCellBalancingStatus() override;
  explicit constexpr HvCellBalancingStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HvCellBalancingStatus(const HvCellBalancingStatus& from);
  HvCellBalancingStatus(HvCellBalancingStatus&& from) noexcept
    : HvCellBalancingStatus() {
    *this = ::std::move(from);
  }

  inline HvCellBalancingStatus& operator=(const HvCellBalancingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline HvCellBalancingStatus& operator=(HvCellBalancingStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HvCellBalancingStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const HvCellBalancingStatus* internal_default_instance() {
    return reinterpret_cast<const HvCellBalancingStatus*>(
               &_HvCellBalancingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(HvCellBalancingStatus& a, HvCellBalancingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(HvCellBalancingStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HvCellBalancingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HvCellBalancingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HvCellBalancingStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HvCellBalancingStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HvCellBalancingStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HvCellBalancingStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.HvCellBalancingStatus";
  }
  protected:
  explicit HvCellBalancingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBalancingStatusFieldNumber = 1,
  };
  // .primary.BalancingStatusType balancing_status = 1;
  void clear_balancing_status();
  ::primary::BalancingStatusType balancing_status() const;
  void set_balancing_status(::primary::BalancingStatusType value);
  private:
  ::primary::BalancingStatusType _internal_balancing_status() const;
  void _internal_set_balancing_status(::primary::BalancingStatusType value);
  public:

  // @@protoc_insertion_point(class_scope:primary.HvCellBalancingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int balancing_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class InvLSendCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.InvLSendCmd) */ {
 public:
  inline InvLSendCmd() : InvLSendCmd(nullptr) {}
  ~InvLSendCmd() override;
  explicit constexpr InvLSendCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvLSendCmd(const InvLSendCmd& from);
  InvLSendCmd(InvLSendCmd&& from) noexcept
    : InvLSendCmd() {
    *this = ::std::move(from);
  }

  inline InvLSendCmd& operator=(const InvLSendCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvLSendCmd& operator=(InvLSendCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvLSendCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvLSendCmd* internal_default_instance() {
    return reinterpret_cast<const InvLSendCmd*>(
               &_InvLSendCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(InvLSendCmd& a, InvLSendCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(InvLSendCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvLSendCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvLSendCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvLSendCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvLSendCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvLSendCmd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvLSendCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.InvLSendCmd";
  }
  protected:
  explicit InvLSendCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegidFieldNumber = 1,
    kByte1FieldNumber = 2,
    kByte2FieldNumber = 3,
  };
  // uint32 regid = 1;
  void clear_regid();
  uint32_t regid() const;
  void set_regid(uint32_t value);
  private:
  uint32_t _internal_regid() const;
  void _internal_set_regid(uint32_t value);
  public:

  // uint32 byte_1 = 2;
  void clear_byte_1();
  uint32_t byte_1() const;
  void set_byte_1(uint32_t value);
  private:
  uint32_t _internal_byte_1() const;
  void _internal_set_byte_1(uint32_t value);
  public:

  // uint32 byte_2 = 3;
  void clear_byte_2();
  uint32_t byte_2() const;
  void set_byte_2(uint32_t value);
  private:
  uint32_t _internal_byte_2() const;
  void _internal_set_byte_2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.InvLSendCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t regid_;
  uint32_t byte_1_;
  uint32_t byte_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// -------------------------------------------------------------------

class InvLStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:primary.InvLStatus) */ {
 public:
  inline InvLStatus() : InvLStatus(nullptr) {}
  ~InvLStatus() override;
  explicit constexpr InvLStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvLStatus(const InvLStatus& from);
  InvLStatus(InvLStatus&& from) noexcept
    : InvLStatus() {
    *this = ::std::move(from);
  }

  inline InvLStatus& operator=(const InvLStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvLStatus& operator=(InvLStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvLStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvLStatus* internal_default_instance() {
    return reinterpret_cast<const InvLStatus*>(
               &_InvLStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(InvLStatus& a, InvLStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(InvLStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvLStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvLStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvLStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvLStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvLStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvLStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "primary.InvLStatus";
  }
  protected:
  explicit InvLStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegidFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // uint32 regid = 1;
  void clear_regid();
  uint32_t regid() const;
  void set_regid(uint32_t value);
  private:
  uint32_t _internal_regid() const;
  void _internal_set_regid(uint32_t value);
  public:

  // uint32 status = 2;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:primary.InvLStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t regid_;
  uint32_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_primary_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SteerVersion

// uint32 component_version = 1;
inline void SteerVersion::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t SteerVersion::_internal_component_version() const {
  return component_version_;
}
inline uint32_t SteerVersion::component_version() const {
  // @@protoc_insertion_point(field_get:primary.SteerVersion.component_version)
  return _internal_component_version();
}
inline void SteerVersion::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void SteerVersion::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.SteerVersion.component_version)
}

// uint32 cancicd_version = 2;
inline void SteerVersion::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t SteerVersion::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t SteerVersion::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.SteerVersion.cancicd_version)
  return _internal_cancicd_version();
}
inline void SteerVersion::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void SteerVersion::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.SteerVersion.cancicd_version)
}

// -------------------------------------------------------------------

// DasVersion

// uint32 component_version = 1;
inline void DasVersion::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t DasVersion::_internal_component_version() const {
  return component_version_;
}
inline uint32_t DasVersion::component_version() const {
  // @@protoc_insertion_point(field_get:primary.DasVersion.component_version)
  return _internal_component_version();
}
inline void DasVersion::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void DasVersion::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.DasVersion.component_version)
}

// uint32 cancicd_version = 2;
inline void DasVersion::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t DasVersion::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t DasVersion::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.DasVersion.cancicd_version)
  return _internal_cancicd_version();
}
inline void DasVersion::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void DasVersion::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.DasVersion.cancicd_version)
}

// -------------------------------------------------------------------

// HvVersion

// uint32 component_version = 1;
inline void HvVersion::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t HvVersion::_internal_component_version() const {
  return component_version_;
}
inline uint32_t HvVersion::component_version() const {
  // @@protoc_insertion_point(field_get:primary.HvVersion.component_version)
  return _internal_component_version();
}
inline void HvVersion::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void HvVersion::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.HvVersion.component_version)
}

// uint32 cancicd_version = 2;
inline void HvVersion::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t HvVersion::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t HvVersion::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.HvVersion.cancicd_version)
  return _internal_cancicd_version();
}
inline void HvVersion::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void HvVersion::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.HvVersion.cancicd_version)
}

// -------------------------------------------------------------------

// LvVersion

// uint32 component_version = 1;
inline void LvVersion::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t LvVersion::_internal_component_version() const {
  return component_version_;
}
inline uint32_t LvVersion::component_version() const {
  // @@protoc_insertion_point(field_get:primary.LvVersion.component_version)
  return _internal_component_version();
}
inline void LvVersion::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void LvVersion::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.LvVersion.component_version)
}

// uint32 cancicd_version = 2;
inline void LvVersion::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t LvVersion::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t LvVersion::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.LvVersion.cancicd_version)
  return _internal_cancicd_version();
}
inline void LvVersion::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void LvVersion::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.LvVersion.cancicd_version)
}

// -------------------------------------------------------------------

// TlmVersion

// uint32 component_version = 1;
inline void TlmVersion::clear_component_version() {
  component_version_ = 0u;
}
inline uint32_t TlmVersion::_internal_component_version() const {
  return component_version_;
}
inline uint32_t TlmVersion::component_version() const {
  // @@protoc_insertion_point(field_get:primary.TlmVersion.component_version)
  return _internal_component_version();
}
inline void TlmVersion::_internal_set_component_version(uint32_t value) {
  
  component_version_ = value;
}
inline void TlmVersion::set_component_version(uint32_t value) {
  _internal_set_component_version(value);
  // @@protoc_insertion_point(field_set:primary.TlmVersion.component_version)
}

// uint32 cancicd_version = 2;
inline void TlmVersion::clear_cancicd_version() {
  cancicd_version_ = 0u;
}
inline uint32_t TlmVersion::_internal_cancicd_version() const {
  return cancicd_version_;
}
inline uint32_t TlmVersion::cancicd_version() const {
  // @@protoc_insertion_point(field_get:primary.TlmVersion.cancicd_version)
  return _internal_cancicd_version();
}
inline void TlmVersion::_internal_set_cancicd_version(uint32_t value) {
  
  cancicd_version_ = value;
}
inline void TlmVersion::set_cancicd_version(uint32_t value) {
  _internal_set_cancicd_version(value);
  // @@protoc_insertion_point(field_set:primary.TlmVersion.cancicd_version)
}

// -------------------------------------------------------------------

// Timestamp

// uint32 timestamp = 1;
inline void Timestamp::clear_timestamp() {
  timestamp_ = 0u;
}
inline uint32_t Timestamp::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t Timestamp::timestamp() const {
  // @@protoc_insertion_point(field_get:primary.Timestamp.timestamp)
  return _internal_timestamp();
}
inline void Timestamp::_internal_set_timestamp(uint32_t value) {
  
  timestamp_ = value;
}
inline void Timestamp::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:primary.Timestamp.timestamp)
}

// -------------------------------------------------------------------

// SetTlmStatus

// .primary.TlmStatusSetType tlm_status_set = 1;
inline void SetTlmStatus::clear_tlm_status_set() {
  tlm_status_set_ = 0;
}
inline ::primary::TlmStatusSetType SetTlmStatus::_internal_tlm_status_set() const {
  return static_cast< ::primary::TlmStatusSetType >(tlm_status_set_);
}
inline ::primary::TlmStatusSetType SetTlmStatus::tlm_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SetTlmStatus.tlm_status_set)
  return _internal_tlm_status_set();
}
inline void SetTlmStatus::_internal_set_tlm_status_set(::primary::TlmStatusSetType value) {
  
  tlm_status_set_ = value;
}
inline void SetTlmStatus::set_tlm_status_set(::primary::TlmStatusSetType value) {
  _internal_set_tlm_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SetTlmStatus.tlm_status_set)
}

// .primary.RaceTypeType race_type = 2;
inline void SetTlmStatus::clear_race_type() {
  race_type_ = 0;
}
inline ::primary::RaceTypeType SetTlmStatus::_internal_race_type() const {
  return static_cast< ::primary::RaceTypeType >(race_type_);
}
inline ::primary::RaceTypeType SetTlmStatus::race_type() const {
  // @@protoc_insertion_point(field_get:primary.SetTlmStatus.race_type)
  return _internal_race_type();
}
inline void SetTlmStatus::_internal_set_race_type(::primary::RaceTypeType value) {
  
  race_type_ = value;
}
inline void SetTlmStatus::set_race_type(::primary::RaceTypeType value) {
  _internal_set_race_type(value);
  // @@protoc_insertion_point(field_set:primary.SetTlmStatus.race_type)
}

// uint32 driver = 3;
inline void SetTlmStatus::clear_driver() {
  driver_ = 0u;
}
inline uint32_t SetTlmStatus::_internal_driver() const {
  return driver_;
}
inline uint32_t SetTlmStatus::driver() const {
  // @@protoc_insertion_point(field_get:primary.SetTlmStatus.driver)
  return _internal_driver();
}
inline void SetTlmStatus::_internal_set_driver(uint32_t value) {
  
  driver_ = value;
}
inline void SetTlmStatus::set_driver(uint32_t value) {
  _internal_set_driver(value);
  // @@protoc_insertion_point(field_set:primary.SetTlmStatus.driver)
}

// uint32 circuit = 4;
inline void SetTlmStatus::clear_circuit() {
  circuit_ = 0u;
}
inline uint32_t SetTlmStatus::_internal_circuit() const {
  return circuit_;
}
inline uint32_t SetTlmStatus::circuit() const {
  // @@protoc_insertion_point(field_get:primary.SetTlmStatus.circuit)
  return _internal_circuit();
}
inline void SetTlmStatus::_internal_set_circuit(uint32_t value) {
  
  circuit_ = value;
}
inline void SetTlmStatus::set_circuit(uint32_t value) {
  _internal_set_circuit(value);
  // @@protoc_insertion_point(field_set:primary.SetTlmStatus.circuit)
}

// -------------------------------------------------------------------

// SteerSystemStatus

// uint32 soc_temp = 1;
inline void SteerSystemStatus::clear_soc_temp() {
  soc_temp_ = 0u;
}
inline uint32_t SteerSystemStatus::_internal_soc_temp() const {
  return soc_temp_;
}
inline uint32_t SteerSystemStatus::soc_temp() const {
  // @@protoc_insertion_point(field_get:primary.SteerSystemStatus.soc_temp)
  return _internal_soc_temp();
}
inline void SteerSystemStatus::_internal_set_soc_temp(uint32_t value) {
  
  soc_temp_ = value;
}
inline void SteerSystemStatus::set_soc_temp(uint32_t value) {
  _internal_set_soc_temp(value);
  // @@protoc_insertion_point(field_set:primary.SteerSystemStatus.soc_temp)
}

// -------------------------------------------------------------------

// Marker

// -------------------------------------------------------------------

// TlmStatus

// .primary.TlmStatusType tlm_status = 1;
inline void TlmStatus::clear_tlm_status() {
  tlm_status_ = 0;
}
inline ::primary::TlmStatusType TlmStatus::_internal_tlm_status() const {
  return static_cast< ::primary::TlmStatusType >(tlm_status_);
}
inline ::primary::TlmStatusType TlmStatus::tlm_status() const {
  // @@protoc_insertion_point(field_get:primary.TlmStatus.tlm_status)
  return _internal_tlm_status();
}
inline void TlmStatus::_internal_set_tlm_status(::primary::TlmStatusType value) {
  
  tlm_status_ = value;
}
inline void TlmStatus::set_tlm_status(::primary::TlmStatusType value) {
  _internal_set_tlm_status(value);
  // @@protoc_insertion_point(field_set:primary.TlmStatus.tlm_status)
}

// .primary.RaceTypeType race_type = 2;
inline void TlmStatus::clear_race_type() {
  race_type_ = 0;
}
inline ::primary::RaceTypeType TlmStatus::_internal_race_type() const {
  return static_cast< ::primary::RaceTypeType >(race_type_);
}
inline ::primary::RaceTypeType TlmStatus::race_type() const {
  // @@protoc_insertion_point(field_get:primary.TlmStatus.race_type)
  return _internal_race_type();
}
inline void TlmStatus::_internal_set_race_type(::primary::RaceTypeType value) {
  
  race_type_ = value;
}
inline void TlmStatus::set_race_type(::primary::RaceTypeType value) {
  _internal_set_race_type(value);
  // @@protoc_insertion_point(field_set:primary.TlmStatus.race_type)
}

// uint32 driver = 3;
inline void TlmStatus::clear_driver() {
  driver_ = 0u;
}
inline uint32_t TlmStatus::_internal_driver() const {
  return driver_;
}
inline uint32_t TlmStatus::driver() const {
  // @@protoc_insertion_point(field_get:primary.TlmStatus.driver)
  return _internal_driver();
}
inline void TlmStatus::_internal_set_driver(uint32_t value) {
  
  driver_ = value;
}
inline void TlmStatus::set_driver(uint32_t value) {
  _internal_set_driver(value);
  // @@protoc_insertion_point(field_set:primary.TlmStatus.driver)
}

// uint32 circuit = 4;
inline void TlmStatus::clear_circuit() {
  circuit_ = 0u;
}
inline uint32_t TlmStatus::_internal_circuit() const {
  return circuit_;
}
inline uint32_t TlmStatus::circuit() const {
  // @@protoc_insertion_point(field_get:primary.TlmStatus.circuit)
  return _internal_circuit();
}
inline void TlmStatus::_internal_set_circuit(uint32_t value) {
  
  circuit_ = value;
}
inline void TlmStatus::set_circuit(uint32_t value) {
  _internal_set_circuit(value);
  // @@protoc_insertion_point(field_set:primary.TlmStatus.circuit)
}

// -------------------------------------------------------------------

// CarStatus

// .primary.InverterStatusType inverter_l = 1;
inline void CarStatus::clear_inverter_l() {
  inverter_l_ = 0;
}
inline ::primary::InverterStatusType CarStatus::_internal_inverter_l() const {
  return static_cast< ::primary::InverterStatusType >(inverter_l_);
}
inline ::primary::InverterStatusType CarStatus::inverter_l() const {
  // @@protoc_insertion_point(field_get:primary.CarStatus.inverter_l)
  return _internal_inverter_l();
}
inline void CarStatus::_internal_set_inverter_l(::primary::InverterStatusType value) {
  
  inverter_l_ = value;
}
inline void CarStatus::set_inverter_l(::primary::InverterStatusType value) {
  _internal_set_inverter_l(value);
  // @@protoc_insertion_point(field_set:primary.CarStatus.inverter_l)
}

// .primary.InverterStatusType inverter_r = 2;
inline void CarStatus::clear_inverter_r() {
  inverter_r_ = 0;
}
inline ::primary::InverterStatusType CarStatus::_internal_inverter_r() const {
  return static_cast< ::primary::InverterStatusType >(inverter_r_);
}
inline ::primary::InverterStatusType CarStatus::inverter_r() const {
  // @@protoc_insertion_point(field_get:primary.CarStatus.inverter_r)
  return _internal_inverter_r();
}
inline void CarStatus::_internal_set_inverter_r(::primary::InverterStatusType value) {
  
  inverter_r_ = value;
}
inline void CarStatus::set_inverter_r(::primary::InverterStatusType value) {
  _internal_set_inverter_r(value);
  // @@protoc_insertion_point(field_set:primary.CarStatus.inverter_r)
}

// .primary.CarStatusType car_status = 3;
inline void CarStatus::clear_car_status() {
  car_status_ = 0;
}
inline ::primary::CarStatusType CarStatus::_internal_car_status() const {
  return static_cast< ::primary::CarStatusType >(car_status_);
}
inline ::primary::CarStatusType CarStatus::car_status() const {
  // @@protoc_insertion_point(field_get:primary.CarStatus.car_status)
  return _internal_car_status();
}
inline void CarStatus::_internal_set_car_status(::primary::CarStatusType value) {
  
  car_status_ = value;
}
inline void CarStatus::set_car_status(::primary::CarStatusType value) {
  _internal_set_car_status(value);
  // @@protoc_insertion_point(field_set:primary.CarStatus.car_status)
}

// -------------------------------------------------------------------

// DasErrors

// uint32 das_error = 1;
inline void DasErrors::clear_das_error() {
  das_error_ = 0u;
}
inline uint32_t DasErrors::_internal_das_error() const {
  return das_error_;
}
inline uint32_t DasErrors::das_error() const {
  // @@protoc_insertion_point(field_get:primary.DasErrors.das_error)
  return _internal_das_error();
}
inline void DasErrors::_internal_set_das_error(uint32_t value) {
  
  das_error_ = value;
}
inline void DasErrors::set_das_error(uint32_t value) {
  _internal_set_das_error(value);
  // @@protoc_insertion_point(field_set:primary.DasErrors.das_error)
}

// -------------------------------------------------------------------

// Speed

// uint32 encoder_r = 1;
inline void Speed::clear_encoder_r() {
  encoder_r_ = 0u;
}
inline uint32_t Speed::_internal_encoder_r() const {
  return encoder_r_;
}
inline uint32_t Speed::encoder_r() const {
  // @@protoc_insertion_point(field_get:primary.Speed.encoder_r)
  return _internal_encoder_r();
}
inline void Speed::_internal_set_encoder_r(uint32_t value) {
  
  encoder_r_ = value;
}
inline void Speed::set_encoder_r(uint32_t value) {
  _internal_set_encoder_r(value);
  // @@protoc_insertion_point(field_set:primary.Speed.encoder_r)
}

// uint32 encoder_l = 2;
inline void Speed::clear_encoder_l() {
  encoder_l_ = 0u;
}
inline uint32_t Speed::_internal_encoder_l() const {
  return encoder_l_;
}
inline uint32_t Speed::encoder_l() const {
  // @@protoc_insertion_point(field_get:primary.Speed.encoder_l)
  return _internal_encoder_l();
}
inline void Speed::_internal_set_encoder_l(uint32_t value) {
  
  encoder_l_ = value;
}
inline void Speed::set_encoder_l(uint32_t value) {
  _internal_set_encoder_l(value);
  // @@protoc_insertion_point(field_set:primary.Speed.encoder_l)
}

// uint32 inverter_r = 3;
inline void Speed::clear_inverter_r() {
  inverter_r_ = 0u;
}
inline uint32_t Speed::_internal_inverter_r() const {
  return inverter_r_;
}
inline uint32_t Speed::inverter_r() const {
  // @@protoc_insertion_point(field_get:primary.Speed.inverter_r)
  return _internal_inverter_r();
}
inline void Speed::_internal_set_inverter_r(uint32_t value) {
  
  inverter_r_ = value;
}
inline void Speed::set_inverter_r(uint32_t value) {
  _internal_set_inverter_r(value);
  // @@protoc_insertion_point(field_set:primary.Speed.inverter_r)
}

// uint32 inverter_l = 4;
inline void Speed::clear_inverter_l() {
  inverter_l_ = 0u;
}
inline uint32_t Speed::_internal_inverter_l() const {
  return inverter_l_;
}
inline uint32_t Speed::inverter_l() const {
  // @@protoc_insertion_point(field_get:primary.Speed.inverter_l)
  return _internal_inverter_l();
}
inline void Speed::_internal_set_inverter_l(uint32_t value) {
  
  inverter_l_ = value;
}
inline void Speed::set_inverter_l(uint32_t value) {
  _internal_set_inverter_l(value);
  // @@protoc_insertion_point(field_set:primary.Speed.inverter_l)
}

// -------------------------------------------------------------------

// HvVoltage

// uint32 pack_voltage = 1;
inline void HvVoltage::clear_pack_voltage() {
  pack_voltage_ = 0u;
}
inline uint32_t HvVoltage::_internal_pack_voltage() const {
  return pack_voltage_;
}
inline uint32_t HvVoltage::pack_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HvVoltage.pack_voltage)
  return _internal_pack_voltage();
}
inline void HvVoltage::_internal_set_pack_voltage(uint32_t value) {
  
  pack_voltage_ = value;
}
inline void HvVoltage::set_pack_voltage(uint32_t value) {
  _internal_set_pack_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HvVoltage.pack_voltage)
}

// uint32 bus_voltage = 2;
inline void HvVoltage::clear_bus_voltage() {
  bus_voltage_ = 0u;
}
inline uint32_t HvVoltage::_internal_bus_voltage() const {
  return bus_voltage_;
}
inline uint32_t HvVoltage::bus_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HvVoltage.bus_voltage)
  return _internal_bus_voltage();
}
inline void HvVoltage::_internal_set_bus_voltage(uint32_t value) {
  
  bus_voltage_ = value;
}
inline void HvVoltage::set_bus_voltage(uint32_t value) {
  _internal_set_bus_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HvVoltage.bus_voltage)
}

// uint32 max_cell_voltage = 3;
inline void HvVoltage::clear_max_cell_voltage() {
  max_cell_voltage_ = 0u;
}
inline uint32_t HvVoltage::_internal_max_cell_voltage() const {
  return max_cell_voltage_;
}
inline uint32_t HvVoltage::max_cell_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HvVoltage.max_cell_voltage)
  return _internal_max_cell_voltage();
}
inline void HvVoltage::_internal_set_max_cell_voltage(uint32_t value) {
  
  max_cell_voltage_ = value;
}
inline void HvVoltage::set_max_cell_voltage(uint32_t value) {
  _internal_set_max_cell_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HvVoltage.max_cell_voltage)
}

// uint32 min_cell_voltage = 4;
inline void HvVoltage::clear_min_cell_voltage() {
  min_cell_voltage_ = 0u;
}
inline uint32_t HvVoltage::_internal_min_cell_voltage() const {
  return min_cell_voltage_;
}
inline uint32_t HvVoltage::min_cell_voltage() const {
  // @@protoc_insertion_point(field_get:primary.HvVoltage.min_cell_voltage)
  return _internal_min_cell_voltage();
}
inline void HvVoltage::_internal_set_min_cell_voltage(uint32_t value) {
  
  min_cell_voltage_ = value;
}
inline void HvVoltage::set_min_cell_voltage(uint32_t value) {
  _internal_set_min_cell_voltage(value);
  // @@protoc_insertion_point(field_set:primary.HvVoltage.min_cell_voltage)
}

// -------------------------------------------------------------------

// HvCurrent

// uint32 current = 1;
inline void HvCurrent::clear_current() {
  current_ = 0u;
}
inline uint32_t HvCurrent::_internal_current() const {
  return current_;
}
inline uint32_t HvCurrent::current() const {
  // @@protoc_insertion_point(field_get:primary.HvCurrent.current)
  return _internal_current();
}
inline void HvCurrent::_internal_set_current(uint32_t value) {
  
  current_ = value;
}
inline void HvCurrent::set_current(uint32_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:primary.HvCurrent.current)
}

// int32 power = 2;
inline void HvCurrent::clear_power() {
  power_ = 0;
}
inline int32_t HvCurrent::_internal_power() const {
  return power_;
}
inline int32_t HvCurrent::power() const {
  // @@protoc_insertion_point(field_get:primary.HvCurrent.power)
  return _internal_power();
}
inline void HvCurrent::_internal_set_power(int32_t value) {
  
  power_ = value;
}
inline void HvCurrent::set_power(int32_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:primary.HvCurrent.power)
}

// -------------------------------------------------------------------

// HvTemp

// uint32 average_temp = 1;
inline void HvTemp::clear_average_temp() {
  average_temp_ = 0u;
}
inline uint32_t HvTemp::_internal_average_temp() const {
  return average_temp_;
}
inline uint32_t HvTemp::average_temp() const {
  // @@protoc_insertion_point(field_get:primary.HvTemp.average_temp)
  return _internal_average_temp();
}
inline void HvTemp::_internal_set_average_temp(uint32_t value) {
  
  average_temp_ = value;
}
inline void HvTemp::set_average_temp(uint32_t value) {
  _internal_set_average_temp(value);
  // @@protoc_insertion_point(field_set:primary.HvTemp.average_temp)
}

// uint32 max_temp = 2;
inline void HvTemp::clear_max_temp() {
  max_temp_ = 0u;
}
inline uint32_t HvTemp::_internal_max_temp() const {
  return max_temp_;
}
inline uint32_t HvTemp::max_temp() const {
  // @@protoc_insertion_point(field_get:primary.HvTemp.max_temp)
  return _internal_max_temp();
}
inline void HvTemp::_internal_set_max_temp(uint32_t value) {
  
  max_temp_ = value;
}
inline void HvTemp::set_max_temp(uint32_t value) {
  _internal_set_max_temp(value);
  // @@protoc_insertion_point(field_set:primary.HvTemp.max_temp)
}

// uint32 min_temp = 3;
inline void HvTemp::clear_min_temp() {
  min_temp_ = 0u;
}
inline uint32_t HvTemp::_internal_min_temp() const {
  return min_temp_;
}
inline uint32_t HvTemp::min_temp() const {
  // @@protoc_insertion_point(field_get:primary.HvTemp.min_temp)
  return _internal_min_temp();
}
inline void HvTemp::_internal_set_min_temp(uint32_t value) {
  
  min_temp_ = value;
}
inline void HvTemp::set_min_temp(uint32_t value) {
  _internal_set_min_temp(value);
  // @@protoc_insertion_point(field_set:primary.HvTemp.min_temp)
}

// -------------------------------------------------------------------

// HvErrors

// uint32 warnings = 1;
inline void HvErrors::clear_warnings() {
  warnings_ = 0u;
}
inline uint32_t HvErrors::_internal_warnings() const {
  return warnings_;
}
inline uint32_t HvErrors::warnings() const {
  // @@protoc_insertion_point(field_get:primary.HvErrors.warnings)
  return _internal_warnings();
}
inline void HvErrors::_internal_set_warnings(uint32_t value) {
  
  warnings_ = value;
}
inline void HvErrors::set_warnings(uint32_t value) {
  _internal_set_warnings(value);
  // @@protoc_insertion_point(field_set:primary.HvErrors.warnings)
}

// uint32 errors = 2;
inline void HvErrors::clear_errors() {
  errors_ = 0u;
}
inline uint32_t HvErrors::_internal_errors() const {
  return errors_;
}
inline uint32_t HvErrors::errors() const {
  // @@protoc_insertion_point(field_get:primary.HvErrors.errors)
  return _internal_errors();
}
inline void HvErrors::_internal_set_errors(uint32_t value) {
  
  errors_ = value;
}
inline void HvErrors::set_errors(uint32_t value) {
  _internal_set_errors(value);
  // @@protoc_insertion_point(field_set:primary.HvErrors.errors)
}

// -------------------------------------------------------------------

// TsStatus

// .primary.TsStatusType ts_status = 1;
inline void TsStatus::clear_ts_status() {
  ts_status_ = 0;
}
inline ::primary::TsStatusType TsStatus::_internal_ts_status() const {
  return static_cast< ::primary::TsStatusType >(ts_status_);
}
inline ::primary::TsStatusType TsStatus::ts_status() const {
  // @@protoc_insertion_point(field_get:primary.TsStatus.ts_status)
  return _internal_ts_status();
}
inline void TsStatus::_internal_set_ts_status(::primary::TsStatusType value) {
  
  ts_status_ = value;
}
inline void TsStatus::set_ts_status(::primary::TsStatusType value) {
  _internal_set_ts_status(value);
  // @@protoc_insertion_point(field_set:primary.TsStatus.ts_status)
}

// -------------------------------------------------------------------

// SetTsStatus

// .primary.TsStatusSetType ts_status_set = 1;
inline void SetTsStatus::clear_ts_status_set() {
  ts_status_set_ = 0;
}
inline ::primary::TsStatusSetType SetTsStatus::_internal_ts_status_set() const {
  return static_cast< ::primary::TsStatusSetType >(ts_status_set_);
}
inline ::primary::TsStatusSetType SetTsStatus::ts_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SetTsStatus.ts_status_set)
  return _internal_ts_status_set();
}
inline void SetTsStatus::_internal_set_ts_status_set(::primary::TsStatusSetType value) {
  
  ts_status_set_ = value;
}
inline void SetTsStatus::set_ts_status_set(::primary::TsStatusSetType value) {
  _internal_set_ts_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SetTsStatus.ts_status_set)
}

// -------------------------------------------------------------------

// SetCellBalancingStatus

// .primary.SetBalancingStatusType set_balancing_status = 1;
inline void SetCellBalancingStatus::clear_set_balancing_status() {
  set_balancing_status_ = 0;
}
inline ::primary::SetBalancingStatusType SetCellBalancingStatus::_internal_set_balancing_status() const {
  return static_cast< ::primary::SetBalancingStatusType >(set_balancing_status_);
}
inline ::primary::SetBalancingStatusType SetCellBalancingStatus::set_balancing_status() const {
  // @@protoc_insertion_point(field_get:primary.SetCellBalancingStatus.set_balancing_status)
  return _internal_set_balancing_status();
}
inline void SetCellBalancingStatus::_internal_set_set_balancing_status(::primary::SetBalancingStatusType value) {
  
  set_balancing_status_ = value;
}
inline void SetCellBalancingStatus::set_set_balancing_status(::primary::SetBalancingStatusType value) {
  _internal_set_set_balancing_status(value);
  // @@protoc_insertion_point(field_set:primary.SetCellBalancingStatus.set_balancing_status)
}

// -------------------------------------------------------------------

// HandcartStatus

// bool connected = 1;
inline void HandcartStatus::clear_connected() {
  connected_ = false;
}
inline bool HandcartStatus::_internal_connected() const {
  return connected_;
}
inline bool HandcartStatus::connected() const {
  // @@protoc_insertion_point(field_get:primary.HandcartStatus.connected)
  return _internal_connected();
}
inline void HandcartStatus::_internal_set_connected(bool value) {
  
  connected_ = value;
}
inline void HandcartStatus::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:primary.HandcartStatus.connected)
}

// -------------------------------------------------------------------

// SteerStatus

// .primary.TractionControlType traction_control = 1;
inline void SteerStatus::clear_traction_control() {
  traction_control_ = 0;
}
inline ::primary::TractionControlType SteerStatus::_internal_traction_control() const {
  return static_cast< ::primary::TractionControlType >(traction_control_);
}
inline ::primary::TractionControlType SteerStatus::traction_control() const {
  // @@protoc_insertion_point(field_get:primary.SteerStatus.traction_control)
  return _internal_traction_control();
}
inline void SteerStatus::_internal_set_traction_control(::primary::TractionControlType value) {
  
  traction_control_ = value;
}
inline void SteerStatus::set_traction_control(::primary::TractionControlType value) {
  _internal_set_traction_control(value);
  // @@protoc_insertion_point(field_set:primary.SteerStatus.traction_control)
}

// .primary.MapType map = 2;
inline void SteerStatus::clear_map() {
  map_ = 0;
}
inline ::primary::MapType SteerStatus::_internal_map() const {
  return static_cast< ::primary::MapType >(map_);
}
inline ::primary::MapType SteerStatus::map() const {
  // @@protoc_insertion_point(field_get:primary.SteerStatus.map)
  return _internal_map();
}
inline void SteerStatus::_internal_set_map(::primary::MapType value) {
  
  map_ = value;
}
inline void SteerStatus::set_map(::primary::MapType value) {
  _internal_set_map(value);
  // @@protoc_insertion_point(field_set:primary.SteerStatus.map)
}

// -------------------------------------------------------------------

// SetCarStatus

// .primary.CarStatusSetType car_status_set = 1;
inline void SetCarStatus::clear_car_status_set() {
  car_status_set_ = 0;
}
inline ::primary::CarStatusSetType SetCarStatus::_internal_car_status_set() const {
  return static_cast< ::primary::CarStatusSetType >(car_status_set_);
}
inline ::primary::CarStatusSetType SetCarStatus::car_status_set() const {
  // @@protoc_insertion_point(field_get:primary.SetCarStatus.car_status_set)
  return _internal_car_status_set();
}
inline void SetCarStatus::_internal_set_car_status_set(::primary::CarStatusSetType value) {
  
  car_status_set_ = value;
}
inline void SetCarStatus::set_car_status_set(::primary::CarStatusSetType value) {
  _internal_set_car_status_set(value);
  // @@protoc_insertion_point(field_set:primary.SetCarStatus.car_status_set)
}

// -------------------------------------------------------------------

// SetPedalsRange

// .primary.BoundType bound = 1;
inline void SetPedalsRange::clear_bound() {
  bound_ = 0;
}
inline ::primary::BoundType SetPedalsRange::_internal_bound() const {
  return static_cast< ::primary::BoundType >(bound_);
}
inline ::primary::BoundType SetPedalsRange::bound() const {
  // @@protoc_insertion_point(field_get:primary.SetPedalsRange.bound)
  return _internal_bound();
}
inline void SetPedalsRange::_internal_set_bound(::primary::BoundType value) {
  
  bound_ = value;
}
inline void SetPedalsRange::set_bound(::primary::BoundType value) {
  _internal_set_bound(value);
  // @@protoc_insertion_point(field_set:primary.SetPedalsRange.bound)
}

// .primary.PedalType pedal = 2;
inline void SetPedalsRange::clear_pedal() {
  pedal_ = 0;
}
inline ::primary::PedalType SetPedalsRange::_internal_pedal() const {
  return static_cast< ::primary::PedalType >(pedal_);
}
inline ::primary::PedalType SetPedalsRange::pedal() const {
  // @@protoc_insertion_point(field_get:primary.SetPedalsRange.pedal)
  return _internal_pedal();
}
inline void SetPedalsRange::_internal_set_pedal(::primary::PedalType value) {
  
  pedal_ = value;
}
inline void SetPedalsRange::set_pedal(::primary::PedalType value) {
  _internal_set_pedal(value);
  // @@protoc_insertion_point(field_set:primary.SetPedalsRange.pedal)
}

// -------------------------------------------------------------------

// LvCurrent

// uint32 current = 1;
inline void LvCurrent::clear_current() {
  current_ = 0u;
}
inline uint32_t LvCurrent::_internal_current() const {
  return current_;
}
inline uint32_t LvCurrent::current() const {
  // @@protoc_insertion_point(field_get:primary.LvCurrent.current)
  return _internal_current();
}
inline void LvCurrent::_internal_set_current(uint32_t value) {
  
  current_ = value;
}
inline void LvCurrent::set_current(uint32_t value) {
  _internal_set_current(value);
  // @@protoc_insertion_point(field_set:primary.LvCurrent.current)
}

// -------------------------------------------------------------------

// LvVoltage

// uint32 total_voltage = 1;
inline void LvVoltage::clear_total_voltage() {
  total_voltage_ = 0u;
}
inline uint32_t LvVoltage::_internal_total_voltage() const {
  return total_voltage_;
}
inline uint32_t LvVoltage::total_voltage() const {
  // @@protoc_insertion_point(field_get:primary.LvVoltage.total_voltage)
  return _internal_total_voltage();
}
inline void LvVoltage::_internal_set_total_voltage(uint32_t value) {
  
  total_voltage_ = value;
}
inline void LvVoltage::set_total_voltage(uint32_t value) {
  _internal_set_total_voltage(value);
  // @@protoc_insertion_point(field_set:primary.LvVoltage.total_voltage)
}

// uint32 voltage_1 = 2;
inline void LvVoltage::clear_voltage_1() {
  voltage_1_ = 0u;
}
inline uint32_t LvVoltage::_internal_voltage_1() const {
  return voltage_1_;
}
inline uint32_t LvVoltage::voltage_1() const {
  // @@protoc_insertion_point(field_get:primary.LvVoltage.voltage_1)
  return _internal_voltage_1();
}
inline void LvVoltage::_internal_set_voltage_1(uint32_t value) {
  
  voltage_1_ = value;
}
inline void LvVoltage::set_voltage_1(uint32_t value) {
  _internal_set_voltage_1(value);
  // @@protoc_insertion_point(field_set:primary.LvVoltage.voltage_1)
}

// uint32 voltage_2 = 3;
inline void LvVoltage::clear_voltage_2() {
  voltage_2_ = 0u;
}
inline uint32_t LvVoltage::_internal_voltage_2() const {
  return voltage_2_;
}
inline uint32_t LvVoltage::voltage_2() const {
  // @@protoc_insertion_point(field_get:primary.LvVoltage.voltage_2)
  return _internal_voltage_2();
}
inline void LvVoltage::_internal_set_voltage_2(uint32_t value) {
  
  voltage_2_ = value;
}
inline void LvVoltage::set_voltage_2(uint32_t value) {
  _internal_set_voltage_2(value);
  // @@protoc_insertion_point(field_set:primary.LvVoltage.voltage_2)
}

// uint32 voltage_3 = 4;
inline void LvVoltage::clear_voltage_3() {
  voltage_3_ = 0u;
}
inline uint32_t LvVoltage::_internal_voltage_3() const {
  return voltage_3_;
}
inline uint32_t LvVoltage::voltage_3() const {
  // @@protoc_insertion_point(field_get:primary.LvVoltage.voltage_3)
  return _internal_voltage_3();
}
inline void LvVoltage::_internal_set_voltage_3(uint32_t value) {
  
  voltage_3_ = value;
}
inline void LvVoltage::set_voltage_3(uint32_t value) {
  _internal_set_voltage_3(value);
  // @@protoc_insertion_point(field_set:primary.LvVoltage.voltage_3)
}

// uint32 voltage_4 = 5;
inline void LvVoltage::clear_voltage_4() {
  voltage_4_ = 0u;
}
inline uint32_t LvVoltage::_internal_voltage_4() const {
  return voltage_4_;
}
inline uint32_t LvVoltage::voltage_4() const {
  // @@protoc_insertion_point(field_get:primary.LvVoltage.voltage_4)
  return _internal_voltage_4();
}
inline void LvVoltage::_internal_set_voltage_4(uint32_t value) {
  
  voltage_4_ = value;
}
inline void LvVoltage::set_voltage_4(uint32_t value) {
  _internal_set_voltage_4(value);
  // @@protoc_insertion_point(field_set:primary.LvVoltage.voltage_4)
}

// -------------------------------------------------------------------

// LvTemperature

// uint32 bp_temperature = 1;
inline void LvTemperature::clear_bp_temperature() {
  bp_temperature_ = 0u;
}
inline uint32_t LvTemperature::_internal_bp_temperature() const {
  return bp_temperature_;
}
inline uint32_t LvTemperature::bp_temperature() const {
  // @@protoc_insertion_point(field_get:primary.LvTemperature.bp_temperature)
  return _internal_bp_temperature();
}
inline void LvTemperature::_internal_set_bp_temperature(uint32_t value) {
  
  bp_temperature_ = value;
}
inline void LvTemperature::set_bp_temperature(uint32_t value) {
  _internal_set_bp_temperature(value);
  // @@protoc_insertion_point(field_set:primary.LvTemperature.bp_temperature)
}

// uint32 dcdc_temperature = 2;
inline void LvTemperature::clear_dcdc_temperature() {
  dcdc_temperature_ = 0u;
}
inline uint32_t LvTemperature::_internal_dcdc_temperature() const {
  return dcdc_temperature_;
}
inline uint32_t LvTemperature::dcdc_temperature() const {
  // @@protoc_insertion_point(field_get:primary.LvTemperature.dcdc_temperature)
  return _internal_dcdc_temperature();
}
inline void LvTemperature::_internal_set_dcdc_temperature(uint32_t value) {
  
  dcdc_temperature_ = value;
}
inline void LvTemperature::set_dcdc_temperature(uint32_t value) {
  _internal_set_dcdc_temperature(value);
  // @@protoc_insertion_point(field_set:primary.LvTemperature.dcdc_temperature)
}

// -------------------------------------------------------------------

// CoolingStatus

// uint32 hv_fan_speed = 1;
inline void CoolingStatus::clear_hv_fan_speed() {
  hv_fan_speed_ = 0u;
}
inline uint32_t CoolingStatus::_internal_hv_fan_speed() const {
  return hv_fan_speed_;
}
inline uint32_t CoolingStatus::hv_fan_speed() const {
  // @@protoc_insertion_point(field_get:primary.CoolingStatus.hv_fan_speed)
  return _internal_hv_fan_speed();
}
inline void CoolingStatus::_internal_set_hv_fan_speed(uint32_t value) {
  
  hv_fan_speed_ = value;
}
inline void CoolingStatus::set_hv_fan_speed(uint32_t value) {
  _internal_set_hv_fan_speed(value);
  // @@protoc_insertion_point(field_set:primary.CoolingStatus.hv_fan_speed)
}

// uint32 lv_fan_speed = 2;
inline void CoolingStatus::clear_lv_fan_speed() {
  lv_fan_speed_ = 0u;
}
inline uint32_t CoolingStatus::_internal_lv_fan_speed() const {
  return lv_fan_speed_;
}
inline uint32_t CoolingStatus::lv_fan_speed() const {
  // @@protoc_insertion_point(field_get:primary.CoolingStatus.lv_fan_speed)
  return _internal_lv_fan_speed();
}
inline void CoolingStatus::_internal_set_lv_fan_speed(uint32_t value) {
  
  lv_fan_speed_ = value;
}
inline void CoolingStatus::set_lv_fan_speed(uint32_t value) {
  _internal_set_lv_fan_speed(value);
  // @@protoc_insertion_point(field_set:primary.CoolingStatus.lv_fan_speed)
}

// uint32 pump_speed = 3;
inline void CoolingStatus::clear_pump_speed() {
  pump_speed_ = 0u;
}
inline uint32_t CoolingStatus::_internal_pump_speed() const {
  return pump_speed_;
}
inline uint32_t CoolingStatus::pump_speed() const {
  // @@protoc_insertion_point(field_get:primary.CoolingStatus.pump_speed)
  return _internal_pump_speed();
}
inline void CoolingStatus::_internal_set_pump_speed(uint32_t value) {
  
  pump_speed_ = value;
}
inline void CoolingStatus::set_pump_speed(uint32_t value) {
  _internal_set_pump_speed(value);
  // @@protoc_insertion_point(field_set:primary.CoolingStatus.pump_speed)
}

// -------------------------------------------------------------------

// HvCellsVoltage

// uint32 cell_index = 1;
inline void HvCellsVoltage::clear_cell_index() {
  cell_index_ = 0u;
}
inline uint32_t HvCellsVoltage::_internal_cell_index() const {
  return cell_index_;
}
inline uint32_t HvCellsVoltage::cell_index() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsVoltage.cell_index)
  return _internal_cell_index();
}
inline void HvCellsVoltage::_internal_set_cell_index(uint32_t value) {
  
  cell_index_ = value;
}
inline void HvCellsVoltage::set_cell_index(uint32_t value) {
  _internal_set_cell_index(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsVoltage.cell_index)
}

// uint32 voltage_0 = 2;
inline void HvCellsVoltage::clear_voltage_0() {
  voltage_0_ = 0u;
}
inline uint32_t HvCellsVoltage::_internal_voltage_0() const {
  return voltage_0_;
}
inline uint32_t HvCellsVoltage::voltage_0() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsVoltage.voltage_0)
  return _internal_voltage_0();
}
inline void HvCellsVoltage::_internal_set_voltage_0(uint32_t value) {
  
  voltage_0_ = value;
}
inline void HvCellsVoltage::set_voltage_0(uint32_t value) {
  _internal_set_voltage_0(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsVoltage.voltage_0)
}

// uint32 voltage_1 = 3;
inline void HvCellsVoltage::clear_voltage_1() {
  voltage_1_ = 0u;
}
inline uint32_t HvCellsVoltage::_internal_voltage_1() const {
  return voltage_1_;
}
inline uint32_t HvCellsVoltage::voltage_1() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsVoltage.voltage_1)
  return _internal_voltage_1();
}
inline void HvCellsVoltage::_internal_set_voltage_1(uint32_t value) {
  
  voltage_1_ = value;
}
inline void HvCellsVoltage::set_voltage_1(uint32_t value) {
  _internal_set_voltage_1(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsVoltage.voltage_1)
}

// uint32 voltage_2 = 4;
inline void HvCellsVoltage::clear_voltage_2() {
  voltage_2_ = 0u;
}
inline uint32_t HvCellsVoltage::_internal_voltage_2() const {
  return voltage_2_;
}
inline uint32_t HvCellsVoltage::voltage_2() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsVoltage.voltage_2)
  return _internal_voltage_2();
}
inline void HvCellsVoltage::_internal_set_voltage_2(uint32_t value) {
  
  voltage_2_ = value;
}
inline void HvCellsVoltage::set_voltage_2(uint32_t value) {
  _internal_set_voltage_2(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsVoltage.voltage_2)
}

// -------------------------------------------------------------------

// HvCellsTemp

// uint32 cell_index = 1;
inline void HvCellsTemp::clear_cell_index() {
  cell_index_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_cell_index() const {
  return cell_index_;
}
inline uint32_t HvCellsTemp::cell_index() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.cell_index)
  return _internal_cell_index();
}
inline void HvCellsTemp::_internal_set_cell_index(uint32_t value) {
  
  cell_index_ = value;
}
inline void HvCellsTemp::set_cell_index(uint32_t value) {
  _internal_set_cell_index(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.cell_index)
}

// uint32 temp_0 = 2;
inline void HvCellsTemp::clear_temp_0() {
  temp_0_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_0() const {
  return temp_0_;
}
inline uint32_t HvCellsTemp::temp_0() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_0)
  return _internal_temp_0();
}
inline void HvCellsTemp::_internal_set_temp_0(uint32_t value) {
  
  temp_0_ = value;
}
inline void HvCellsTemp::set_temp_0(uint32_t value) {
  _internal_set_temp_0(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_0)
}

// uint32 temp_1 = 3;
inline void HvCellsTemp::clear_temp_1() {
  temp_1_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_1() const {
  return temp_1_;
}
inline uint32_t HvCellsTemp::temp_1() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_1)
  return _internal_temp_1();
}
inline void HvCellsTemp::_internal_set_temp_1(uint32_t value) {
  
  temp_1_ = value;
}
inline void HvCellsTemp::set_temp_1(uint32_t value) {
  _internal_set_temp_1(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_1)
}

// uint32 temp_2 = 4;
inline void HvCellsTemp::clear_temp_2() {
  temp_2_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_2() const {
  return temp_2_;
}
inline uint32_t HvCellsTemp::temp_2() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_2)
  return _internal_temp_2();
}
inline void HvCellsTemp::_internal_set_temp_2(uint32_t value) {
  
  temp_2_ = value;
}
inline void HvCellsTemp::set_temp_2(uint32_t value) {
  _internal_set_temp_2(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_2)
}

// uint32 temp_3 = 5;
inline void HvCellsTemp::clear_temp_3() {
  temp_3_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_3() const {
  return temp_3_;
}
inline uint32_t HvCellsTemp::temp_3() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_3)
  return _internal_temp_3();
}
inline void HvCellsTemp::_internal_set_temp_3(uint32_t value) {
  
  temp_3_ = value;
}
inline void HvCellsTemp::set_temp_3(uint32_t value) {
  _internal_set_temp_3(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_3)
}

// uint32 temp_4 = 6;
inline void HvCellsTemp::clear_temp_4() {
  temp_4_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_4() const {
  return temp_4_;
}
inline uint32_t HvCellsTemp::temp_4() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_4)
  return _internal_temp_4();
}
inline void HvCellsTemp::_internal_set_temp_4(uint32_t value) {
  
  temp_4_ = value;
}
inline void HvCellsTemp::set_temp_4(uint32_t value) {
  _internal_set_temp_4(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_4)
}

// uint32 temp_5 = 7;
inline void HvCellsTemp::clear_temp_5() {
  temp_5_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_5() const {
  return temp_5_;
}
inline uint32_t HvCellsTemp::temp_5() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_5)
  return _internal_temp_5();
}
inline void HvCellsTemp::_internal_set_temp_5(uint32_t value) {
  
  temp_5_ = value;
}
inline void HvCellsTemp::set_temp_5(uint32_t value) {
  _internal_set_temp_5(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_5)
}

// uint32 temp_6 = 8;
inline void HvCellsTemp::clear_temp_6() {
  temp_6_ = 0u;
}
inline uint32_t HvCellsTemp::_internal_temp_6() const {
  return temp_6_;
}
inline uint32_t HvCellsTemp::temp_6() const {
  // @@protoc_insertion_point(field_get:primary.HvCellsTemp.temp_6)
  return _internal_temp_6();
}
inline void HvCellsTemp::_internal_set_temp_6(uint32_t value) {
  
  temp_6_ = value;
}
inline void HvCellsTemp::set_temp_6(uint32_t value) {
  _internal_set_temp_6(value);
  // @@protoc_insertion_point(field_set:primary.HvCellsTemp.temp_6)
}

// -------------------------------------------------------------------

// HvCellBalancingStatus

// .primary.BalancingStatusType balancing_status = 1;
inline void HvCellBalancingStatus::clear_balancing_status() {
  balancing_status_ = 0;
}
inline ::primary::BalancingStatusType HvCellBalancingStatus::_internal_balancing_status() const {
  return static_cast< ::primary::BalancingStatusType >(balancing_status_);
}
inline ::primary::BalancingStatusType HvCellBalancingStatus::balancing_status() const {
  // @@protoc_insertion_point(field_get:primary.HvCellBalancingStatus.balancing_status)
  return _internal_balancing_status();
}
inline void HvCellBalancingStatus::_internal_set_balancing_status(::primary::BalancingStatusType value) {
  
  balancing_status_ = value;
}
inline void HvCellBalancingStatus::set_balancing_status(::primary::BalancingStatusType value) {
  _internal_set_balancing_status(value);
  // @@protoc_insertion_point(field_set:primary.HvCellBalancingStatus.balancing_status)
}

// -------------------------------------------------------------------

// InvLSendCmd

// uint32 regid = 1;
inline void InvLSendCmd::clear_regid() {
  regid_ = 0u;
}
inline uint32_t InvLSendCmd::_internal_regid() const {
  return regid_;
}
inline uint32_t InvLSendCmd::regid() const {
  // @@protoc_insertion_point(field_get:primary.InvLSendCmd.regid)
  return _internal_regid();
}
inline void InvLSendCmd::_internal_set_regid(uint32_t value) {
  
  regid_ = value;
}
inline void InvLSendCmd::set_regid(uint32_t value) {
  _internal_set_regid(value);
  // @@protoc_insertion_point(field_set:primary.InvLSendCmd.regid)
}

// uint32 byte_1 = 2;
inline void InvLSendCmd::clear_byte_1() {
  byte_1_ = 0u;
}
inline uint32_t InvLSendCmd::_internal_byte_1() const {
  return byte_1_;
}
inline uint32_t InvLSendCmd::byte_1() const {
  // @@protoc_insertion_point(field_get:primary.InvLSendCmd.byte_1)
  return _internal_byte_1();
}
inline void InvLSendCmd::_internal_set_byte_1(uint32_t value) {
  
  byte_1_ = value;
}
inline void InvLSendCmd::set_byte_1(uint32_t value) {
  _internal_set_byte_1(value);
  // @@protoc_insertion_point(field_set:primary.InvLSendCmd.byte_1)
}

// uint32 byte_2 = 3;
inline void InvLSendCmd::clear_byte_2() {
  byte_2_ = 0u;
}
inline uint32_t InvLSendCmd::_internal_byte_2() const {
  return byte_2_;
}
inline uint32_t InvLSendCmd::byte_2() const {
  // @@protoc_insertion_point(field_get:primary.InvLSendCmd.byte_2)
  return _internal_byte_2();
}
inline void InvLSendCmd::_internal_set_byte_2(uint32_t value) {
  
  byte_2_ = value;
}
inline void InvLSendCmd::set_byte_2(uint32_t value) {
  _internal_set_byte_2(value);
  // @@protoc_insertion_point(field_set:primary.InvLSendCmd.byte_2)
}

// -------------------------------------------------------------------

// InvLStatus

// uint32 regid = 1;
inline void InvLStatus::clear_regid() {
  regid_ = 0u;
}
inline uint32_t InvLStatus::_internal_regid() const {
  return regid_;
}
inline uint32_t InvLStatus::regid() const {
  // @@protoc_insertion_point(field_get:primary.InvLStatus.regid)
  return _internal_regid();
}
inline void InvLStatus::_internal_set_regid(uint32_t value) {
  
  regid_ = value;
}
inline void InvLStatus::set_regid(uint32_t value) {
  _internal_set_regid(value);
  // @@protoc_insertion_point(field_set:primary.InvLStatus.regid)
}

// uint32 status = 2;
inline void InvLStatus::clear_status() {
  status_ = 0u;
}
inline uint32_t InvLStatus::_internal_status() const {
  return status_;
}
inline uint32_t InvLStatus::status() const {
  // @@protoc_insertion_point(field_get:primary.InvLStatus.status)
  return _internal_status();
}
inline void InvLStatus::_internal_set_status(uint32_t value) {
  
  status_ = value;
}
inline void InvLStatus::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:primary.InvLStatus.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace primary

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::primary::TlmStatusSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::TlmStatusSetType>() {
  return ::primary::TlmStatusSetType_descriptor();
}
template <> struct is_proto_enum< ::primary::RaceTypeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::RaceTypeType>() {
  return ::primary::RaceTypeType_descriptor();
}
template <> struct is_proto_enum< ::primary::TlmStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::TlmStatusType>() {
  return ::primary::TlmStatusType_descriptor();
}
template <> struct is_proto_enum< ::primary::InverterStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::InverterStatusType>() {
  return ::primary::InverterStatusType_descriptor();
}
template <> struct is_proto_enum< ::primary::CarStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::CarStatusType>() {
  return ::primary::CarStatusType_descriptor();
}
template <> struct is_proto_enum< ::primary::TsStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::TsStatusType>() {
  return ::primary::TsStatusType_descriptor();
}
template <> struct is_proto_enum< ::primary::TsStatusSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::TsStatusSetType>() {
  return ::primary::TsStatusSetType_descriptor();
}
template <> struct is_proto_enum< ::primary::SetBalancingStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::SetBalancingStatusType>() {
  return ::primary::SetBalancingStatusType_descriptor();
}
template <> struct is_proto_enum< ::primary::TractionControlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::TractionControlType>() {
  return ::primary::TractionControlType_descriptor();
}
template <> struct is_proto_enum< ::primary::MapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::MapType>() {
  return ::primary::MapType_descriptor();
}
template <> struct is_proto_enum< ::primary::CarStatusSetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::CarStatusSetType>() {
  return ::primary::CarStatusSetType_descriptor();
}
template <> struct is_proto_enum< ::primary::BoundType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::BoundType>() {
  return ::primary::BoundType_descriptor();
}
template <> struct is_proto_enum< ::primary::PedalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::PedalType>() {
  return ::primary::PedalType_descriptor();
}
template <> struct is_proto_enum< ::primary::BalancingStatusType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::primary::BalancingStatusType>() {
  return ::primary::BalancingStatusType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_primary_2eproto
